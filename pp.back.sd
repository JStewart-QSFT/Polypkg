# HP-UX's Software Distributor backend
# [1] http://docs.hp.com/en/B2355-90979/ch10.html

pp_platforms="$pp_platforms sd"

#@ pp_backend_sd_detect(uname_s): return true if matches uname on sd
pp_backend_sd_detect () {
    test x"$1" = x"HP-UX"
}

#@ pp_backend_sd_init(): initialises platform variables for sd 
pp_backend_sd_init () {
    pp_sd_sudo=sudo     # FIXME: argh why is hpux so braindead
}

#@ pp_sd_write_files() <file-list: writes PSF lines for each file
pp_sd_write_files () {
    typeset t m o g f p st line dm
    while read t m o g f p st; do
        line="                file"
        case "$f" in *v*) line="$line -v";; esac    # FIXME for uninstall
        case $t in 
            f) dm=644;;
            d) line="$line -t d"; p=${p%/}; dm=755;;
            s) line="$line -t s";;
        esac

        test x"$o" = x"-" && o=bin
        test x"$g" = x"-" && g=bin
        test x"$m" = x"-" && m=$dm

        if test $t != s; then
            line="$line -o $o -g $g -m $m"
        fi

        echo "$line $pp_destdir$p $p"

    done
}

#@ pp_sw_make_service(svc)
#-- see man page rc(1M)
pp_sw_make_service () {
    typeset svc

    svc="$1"
    pp_load_service_vars "$svc"

    test -n "$user" &&
        cmd="su $user $cmd"
    if test -z "$pidfile"; then
        pidfile="/var/run/$svc.pid"
        cmd="$cmd & echo \$! > \$pidfile"
    fi

    cat <<. 
#!/sbin/sh
# generated by pp $pp_version

        svc="$svc"
        pidfile="$pidfile"

        pp_start () {
            $cmd
        }

.

    cat <<'.'

        pp_stop () {
            if test ! -s "$pidfile"; then
                echo "ERROR: $pidfile MISSING"
                return 1
            else
                read pid < "$pidfile" 
                if kill -$stop_signal "$pid"; then
                    rm -f "$pidfile"
                    return 0
                else
                    echo "ERROR: unable to stop $svc (not running)"
                fi
            fi
        }


        case $1 in
            start_msg) echo "Starting the $svc service";;
            stop_msg)  echo "Stopping the $svc service";;
            start)  
                    ENABLE=yes
                    if test -f /etc/rc.config.d/$svc; then
                        . /etc/rc.config.d/$svc
                    fi
                    if x"$ENABLE" != x"yes"; then
                        exit 2
                    elif pp_start; then
                        echo "$svc started";
                        exit 4
                    else
                        exit 1
                    fi;;
            stop)   if pp_stop; then
                        echo "$svc stopped";
                        exit 0
                    else
                        exit 1
                    fi;;
            *) echo "usage: $0 {start|stop|start_msg|stop_msg}"
               exit 1;;
        esac
.
}

#@ pp_sd_control (name files...) creates and emits a control script
#  based on section "Control Script Format" in [1] 
pp_sd_control () {
    typeset ctrl script

    ctrl="$1"; shift
    script="$pp_wrkdir/control.$ctrl"
    cat <<. >$script
#! /sbin/sh
########
# Product: $name
# $ctrl
# Generated from $pp_opt_input by pp
########
#
# ${copyright:-(no copyright information)}
#
########
.
    cat "$@" >> $script
    /usr/bin/chmod +x $script
    echo "$ctrl $script"
}

#@ pp_backend_sd(): processes output files to generate a package files
pp_backend_sd () {
    typeset psf cpt svc outfile

    psf=$pp_wrkdir/psf

    echo "depot" > $psf
    echo "layout_version 1.0" >>$psf

    #-- vendor
    cat <<. >>$psf
        vendor
            tag             Quest
            title           Quest Software, Inc.

        product
            tag             $name
            revision        $version
            vendor_tag      Quest
            is_patch        false
            title           "$summary"
            description     "$descrption"
            copyright       "$copyright"
            machine_type    *
            os_name         HP-UX
            os_release      ?.11.*
            os_version      ?
            directory       /
            is_locatable    false
.

    for cpt in $pp_components; do
        cat <<. >>$psf
            fileset
                tag             $cpt
                title           $cpt
.

        #-- we put the post/preun code into configure/unconfigure
        # and not postinstall/preremove, because configure/unconfigure
        # scripts are run on the hosts where the package is installed,
        # not loaded (a subtle difference).
        test -s $pp_wrkdir/%post.$cpt &&
            pp_sd_control configure $pp_wrkdir/%post.$cpt >> $psf
        test -s $pp_wrkdir/%preun.$cpt &&
            pp_sd_control unconfigure $pp_wrkdir/%preun.$cpt >> $psf

        if $cpt = run -a -n "$pp_services"; then
            # XXX length of $svc should be 10 characters or less
            for svc in $pp_services; do
                pp_sw_make_service $svc > $pp_wkrdir/init.$svc
                echo "file -m 755 -o bin -g bin" \
                        "/sbin/init.d/$svc=$pp_wkrdir/init.$svc" >> $psf

                # TODO incomplete: link in services
                # create symlinks /sbin/rc${level}.d/S$priority$svc
                # where priority is a 3 digit number (eg 060)
            done
        fi

        pp_sd_write_files < $pp_wrkdir/%files.$cpt >> $psf

        #-- end fileset clause
        cat <<. >>$psf
            end
.
        
    done

    #-- end product clause
    cat <<. >>$psf
        end
.

    $pp_opt_debug && cat $psf >&2

    test -s $pp_wrkdir/%fixup && . $pp_wrkdir/%fixup

    outfile=`pp_backend_sd_names`
    if pp_verbose ${pp_sd_sudo} swpackage \
        -s $psf \
        -x run_as_superuser=false \
        -x media_type=tape \
        @ $pp_wrkdir/$outfile
    then
        pp_verbose ${pp_sd_sudo} swlist -l file -s $pp_wrkdir/$outfile
    else
        pp_error "swpackage failed"
    fi
}

#@ pp_backend_sd_cleanup(): removes any files created outside $pp_wrkdir
pp_backend_sd_cleanup () {
    :
}

#@ pp_backend_sd_names(): prints the paths to package files
#    each path should start with $name-$version
#    the package must be relative to the $pp_wrkdir directory
pp_backend_sd_names () {
    echo "$name-$version.depot"
}

#@ pp_backend_sd_install(component): installs package containing the cpt
pp_backend_sd_install () {
    ${pp_sd_sudo} swinstall -s $PWD/`pp_backend_sd_names` $name.$1
}
