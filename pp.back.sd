# HP-UX's Software Distributor backend
# [1] http://docs.hp.com/en/B2355-90979/ch10.html

pp_platforms="$pp_platforms sd"

#@ pp_backend_sd_detect(uname_s): return true if matches uname on sd
pp_backend_sd_detect () {
    test x"$1" = x"HP-UX"
}

#@ pp_backend_sd_init(): initialises platform variables for sd 
pp_backend_sd_init () {
    pp_sd_sudo=sudo     # FIXME: argh why is hpux so braindead
    pp_sd_startlevels=2
    pp_sd_stoplevels=auto
    pp_sd_config_file=
    pp_sd_default_start=1           # config_file default start value

    pp_readlink_fn=pp_ls_readlink   # HPUX has no readlink

    pp_sd_detect_os
}

pp_sd_detect_os () {
    typeset revision

    revision=`uname -r`
    pp_sd_os="${revision#?.}"
    test -z "$pp_sd_os" &&
        pp_warn "cannot detect OS version"
}

#@ pp_sd_write_files() <file-list: writes PSF lines for each file
pp_sd_write_files () {
    typeset t m o g f p st line dm
    while read t m o g f p st; do
        line="                file"
        case "$f" in *v*) line="$line -v";; esac    # FIXME for uninstall
        case $t in 
            f) dm=644;;
            d) line="$line -t d"; p=${p%/}; dm=755;;
            s) line="$line -t s";;
        esac

        test x"$o" = x"-" && o=bin
        test x"$g" = x"-" && g=bin
        test x"$m" = x"-" && m=$dm

        case $t in
            s) echo "$line $st $p";;
            *) echo "$line -o $o -g $g -m $m $pp_destdir$p $p";;
        esac

    done
}

#@ pp_sd_service_script(svc): creates a service script in the run component
# See rc(1M) for more info
pp_sd_service_script () {
    typeset svc config_file config_value scriptpath out

    svc="$1"
    scriptpath="/sbin/init.d/$svc"

    config_file=${pp_sd_config_file:-/etc/rc.config.d/$name}
    sd_config_var=`echo start-$svc | tr '[a-z]-' '[A-Z]_'`
    sd_config_value=${pp_sd_default_start:-0}
    pp_load_service_vars "$svc"

    test -n "$user" &&
        cmd="su $user $cmd"
    if test -z "$pidfile"; then
        pidfile="/var/run/$svc.pid"
        cmd="$cmd & echo \$! > \$pidfile"
    fi

pp_debug "config file is $config_file"

    pp_add_file_if_missing $scriptpath run 755
    pp_add_file_if_missing $config_file run 644 v

    cat <<-. >> $pp_destdir$config_file

	# Controls whether the $svc service is started
	$sd_config_var=$sd_config_value
.

    cat <<. > $pp_destdir$scriptpath
#!/sbin/sh
# generated by pp $pp_version

        svc="$svc"
        pidfile="$pidfile"
        config_file="$config_file"

        pp_start () {
            $cmd
        }

        pp_disabled () {
            test \${$sd_config_var:-0} -eq 0
        }

.

    cat <<'.' >>$pp_destdir$scriptpath

        pp_stop () {
            if test ! -s "$pidfile"; then
                echo "ERROR: $pidfile MISSING"
                return 1
            else
                read pid < "$pidfile" 
                if kill -$stop_signal "$pid"; then
                    rm -f "$pidfile"
                    return 0
                else
                    echo "ERROR: unable to stop $svc (not running)"
                fi
            fi
        }

        pp_running () {
            if test ! -s "$pidfile"; then
                return 1
            else
                read pid < "$pidfile" 
                kill -0 "$pid" 2>/dev/null
            fi
        }

        case $1 in
            start_msg) echo "Starting the $svc service";;
            stop_msg)  echo "Stopping the $svc service";;
            start)  
                    if test -f "$config_file"; then
                        . $config_file
                    fi
                    if pp_disabled; then
                        exit 2
                    elif pp_running; then
                        echo "$svc already running";
                        exit 0
                    elif pp_start; then
                        echo "$svc started";
                        exit 4
                    else
                        exit 1
                    fi;;
            stop)   if pp_stop; then
                        echo "$svc stopped";
                        exit 0
                    else
                        exit 1
                    fi;;
            *) echo "usage: $0 {start|stop|start_msg|stop_msg}"
               exit 1;;
        esac
.
}

#@ pp_sd_make_service($svc): create the service files and links
pp_sd_make_service () {
        typeset level priority startlevels stoplevels
        typeset svc
        svc="$1"

        #-- don't do anything if the script exists
        if test -s "$pp_destdir/sbin/init.d/$svc"; then
            pp_error "$pp_destdir/sbin/init.d/$svc exists"
            return
        fi

        # symlink the script, depending on the priorities chosen
        eval priority='${pp_sd_priority_'$svc'}'
        test -z "$priority" && priority="${pp_sd_priority:-50}"

        eval startlevels='${pp_sd_startlevels_'$svc'}'
        test -z "$startlevels" && startlevels="$pp_sd_startlevels"

        eval stoplevels='${pp_sd_stoplevels_'$svc'}'
        test -z "$stoplevels" && stoplevels="$pp_sd_stoplevels"

        # create the script and config file
        pp_sd_service_script $svc

        # fix the priority up
        case "$priority" in 
            ???) :;;
            ??) priority=0$priority;;
            ?) priority=00$priority;;
        esac

        if test x"$stoplevels" = x"auto"; then
            stoplevels=
            test -z "$startlevels" || for level in $startlevels; do
                stoplevels="$stoplevels `expr $level - 1`"
            done
        fi

        # create the symlinks
        test -z "$startlevels" || for level in $startlevels; do
            echo "                file -t s" \
                    "/sbin/init.d/$svc" \
                    "/sbin/rc$level.d/S$priority$svc"
        done
        test -z "$stoplevels" || for level in $stoplevels; do
            echo "                file -t s" \
                    "/sbin/init.d/$svc" \
                    "/sbin/rc$level.d/K$priority$svc" 
        done
}


#@ pp_sd_control (name files...) creates and emits a control script
#  based on section "Control Script Format" in [1] 
pp_sd_control () {
    typeset ctrl script

    ctrl="$1"; shift
    script="$pp_wrkdir/control.$ctrl"
    cat <<. >$script
#! /sbin/sh
########
# Product: $name
# $ctrl
# Generated from $pp_opt_input by pp
########
#
# ${copyright:-(no copyright information)}
#
########
.
    cat "$@" >> $script
    /usr/bin/chmod +x $script
    echo "                $ctrl $script"
}

#@ pp_backend_sd(): processes output files to generate a package files
pp_backend_sd () {
    typeset psf cpt svc outfile

    psf=$pp_wrkdir/psf

    echo "depot" > $psf
    echo "layout_version 1.0" >>$psf

    #-- vendor
    cat <<. >>$psf
        vendor
            tag             Quest
            title           Quest Software, Inc.

        product
            tag             $name
            revision        $version
            vendor_tag      Quest
            is_patch        false
            title           "$summary"
            copyright       "$copyright"
            machine_type    *
            os_name         HP-UX
            os_release      ?.11.*
            os_version      ?
            directory       /
            is_locatable    false
.
    test -n "$description" && cat <<. >>$psf
            description     "$description"
.

    for cpt in $pp_components; do
        cat <<. >>$psf
            fileset
                tag             $cpt
                title           $cpt
.

        #-- we put the post/preun code into configure/unconfigure
        # and not postinstall/preremove, because configure/unconfigure
        # scripts are run on the hosts where the package is installed,
        # not loaded (a subtle difference).
        test -s $pp_wrkdir/%post.$cpt &&
            pp_sd_control configure $pp_wrkdir/%post.$cpt >> $psf
        test -s $pp_wrkdir/%preun.$cpt &&
            pp_sd_control unconfigure $pp_wrkdir/%preun.$cpt >> $psf

        if test $cpt = run -a -n "$pp_services"; then
            for svc in $pp_services; do
                #-- service names are 10 chars max on hpux
                case "$svc" in ???????????*) 
                    pp_warn "service name '$svc' is too long for hpux";;
                esac
                pp_sd_make_service $svc >> $psf
            done
            #pp_sd_make_service_config
        fi

        pp_sd_write_files < $pp_wrkdir/%files.$cpt >> $psf

        #-- end fileset clause
        cat <<. >>$psf
            end
.
        
    done

    #-- end product clause
    cat <<. >>$psf
        end
.

    $pp_opt_debug && cat $psf >&2

    test -s $pp_wrkdir/%fixup && . $pp_wrkdir/%fixup

    outfile=`pp_backend_sd_names`
    if pp_verbose ${pp_sd_sudo} swpackage \
        -s $psf \
        -x run_as_superuser=false \
        -x media_type=tape \
        @ $pp_wrkdir/$outfile
    then
        pp_verbose ${pp_sd_sudo} swlist -l file -s $pp_wrkdir/$outfile
    else
        pp_error "swpackage failed"
    fi
}

#@ pp_backend_sd_cleanup(): removes any files created outside $pp_wrkdir
pp_backend_sd_cleanup () {
    :
}

#@ pp_backend_sd_names(): prints the paths to package files
#    each path should start with $name-$version
#    the package must be relative to the $pp_wrkdir directory
pp_backend_sd_names () {
    echo "$name-$version${pp_sd_os:+-hpux$pp_sd_os}.depot"
}

#@ pp_backend_sd_install_script(): generate a helper install script
pp_backend_sd_install_script () {
    typeset pkgname

    pkgname=`pp_backend_sd_names`

    echo "#!/bin/sh"
    pp_install_script_common
    cat <<.

        cpt_to_tags () {
            test x"\$*" = x"all" && set -- $pp_components
            for cpt
            do
                echo "$name.\$cpt"
            done
        }

        test \$# -eq 0 && usage
        op="\$1"; shift

        case "\$op" in 
            list-components)
                test \$# -eq 0 || usage
                echo "$pp_components"
                ;;
            list-services)
                test \$# -eq 0 || usage
                echo "$pp_services"
                ;;
            list-files)
                test \$# -ge 1 || usage
                echo \${PP_PKGDESTDIR:-.}/$pkgname
                ;;
            install)
                test \$# -ge 1 || usage
                swinstall -x verbose=0 \
                    -s \${PP_PKGDESTDIR:-\`pwd\`}/$pkgname \
                    \`cpt_to_tags "\$@"\`
                ;;
            uninstall)
                test \$# -ge 1 || usage
                swremove -x verbose=0 \
                    \`cpt_to_tags "\$@"\`
                ;;
            start|stop)
                test \$# -ge 1 || usage
                for svc
                do
                    /sbin/init.d/\$svc \$op
                done
                ;;
            *)
                usage
                ;;
        esac
.
}

#@ pp_backend_sd_function(func): output platform-dependent function
pp_backend_sd_function () {
    case "$1" in
        pp_mkgroup) cat <<'.';;
            grep "^$1:" /etc/group >/dev/null ||
                /usr/sbin/groupadd $1
.
        pp_mkuser) cat <<'.';;
            typeset user
            eval user=\$$#
            grep "^$user:" /etc/passwd >/dev/null ||
                /usr/sbin/useradd -s /usr/bin/false "$@"
.
        pp_havelib) cat <<'.';;
            typeset dir
            for dir in `echo /usr/lib${3+:$3} | tr : ' '`; do
                test -r "$dir/lib$1.${2-sl}" && return 0
            done
            return 1
.
        *) pp_error "unknown function request: $1";;
    esac
}
