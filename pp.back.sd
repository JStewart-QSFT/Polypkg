# HP-UX's Software Distributor backend
# [1] http://docs.hp.com/en/B2355-90979/ch10.html

pp_platforms="$pp_platforms sd"

#@ pp_backend_sd_detect(uname_s): return true if matches uname on sd
pp_backend_sd_detect () {
    test x"$1" = x"HP-UX"
}

#@ pp_backend_sd_init(): initialises platform variables for sd
pp_backend_sd_init () {
    pp_sd_sudo=sudo     # FIXME: argh why is hpux so braindead
    pp_sd_startlevels=2
    pp_sd_stoplevels=auto
    pp_sd_config_file=
    pp_sd_vendor=
    pp_sd_vendor_tag=Quest
    pp_sd_default_start=1           # config_file default start value

    pp_readlink_fn=pp_ls_readlink   # HPUX has no readlink

    pp_sd_detect_os
}

#@ pp_sd_detect_os(): detect and set operating system vars
pp_sd_detect_os () {
    typeset revision

    revision=`uname -r`
    pp_sd_os="${revision#?.}"
    test -z "$pp_sd_os" &&
        pp_warn "cannot detect OS version"
    pp_sd_os_std="hpux`echo $pp_sd_os | tr -d .`"

    case "`uname -m`" in
	9000/[678]??) pp_sd_arch_std=hppa;;
	ia64) pp_sd_arch_std=ia64;;
	*) pp_sd_arch_std=unknown;;
    esac
}

#@ pp_sd_write_files() <file-list: writes PSF lines for each file
pp_sd_write_files () {
    typeset t m o g f p st line dm
    while read t m o g f p st; do
        line="                file"
        case "$f" in *v*) line="$line -v";; esac    # FIXME for uninstall
        case $t in
            f) dm=644;;
            d) line="$line -t d"; p=${p%/}; dm=755;;
            s) line="$line -t s";;
        esac

        test x"$o" = x"-" && o=root
        test x"$g" = x"-" && g=sys
        test x"$m" = x"-" && m=$dm

        case $t in
            s) echo "$line $st $p";;
            *) echo "$line -o $o -g $g -m $m $pp_destdir$p $p";;
        esac

    done
}

#@ pp_sd_service_group_script (grp "svcs"): creates service group script
pp_sd_service_group_script () {
    typeset grp svcs scriptpath out
    grp="$1"
    svcs="$2"
    scriptpath="/sbin/init.d/$grp"
    out="$pp_destdir$scriptpath"

    pp_add_file_if_missing $scriptpath run 755 || return 0

    cat <<-. > $out
	#!/sbin/sh
	# generated by pp $pp_version
	svcs="$svcs"
.

    cat <<-'.' >> $out
        #-- starts services in order.. stops them all if any break
        pp_start () {
            undo=
            for svc in $svcs; do
                /sbin/init.d/$svc start
		case $? in
		  0|4)
		    undo="$svc $undo"
		    ;;
		  *)
                    if test -n "$undo"; then
                        for svc in $undo; do
                           /sbin/init.d/$svc stop
                        done
                        return 1
                    fi
		    ;;
                esac
            done
            return 0
        }

        #-- stops services in reverse
        pp_stop () {
            reverse=
            for svc in $svcs; do
                reverse="$svc $reverse"
            done
            rc=0
            for svc in $reverse; do
                /sbin/init.d/$svc stop || rc=$?
            done
            return $rc
        }

        case $1 in
            start_msg) echo "Starting $svcs";;
            stop_msg)  echo "Stopping $svcs";;
	    start)     pp_start;;
	    stop)      pp_stop;;
            *)	       echo "usage: $0 {start|stop|start_msg|stop_msg}"
                       exit 1;;
        esac
.
}

#@ pp_sd_service_script(svc): creates a service script in the run component
# See rc(1M) for more info
pp_sd_service_script () {
    typeset svc config_file config_value scriptpath out

    svc="$1"
    scriptpath="/sbin/init.d/$svc"

    config_file=${pp_sd_config_file:-/etc/rc.config.d/$svc}
    sd_config_var=`echo run-$svc | tr '[a-z]-' '[A-Z]_'`
    sd_config_value=${pp_sd_default_start:-0}
    pp_load_service_vars "$svc"

    test -n "$user" -a x"$user" != x"root" &&
        cmd="SHELL=/usr/bin/sh /usr/bin/su $user -c \"exec `echo $cmd | sed -e 's,[$\\\`],\\&,g'`\""
    if test -z "$pidfile"; then
        pidfile="/var/run/$svc.pid"
        cmd="$cmd & echo \$! > \$pidfile"
    fi

    pp_debug "config file is $config_file"

    pp_add_file_if_missing $scriptpath run 755
    pp_add_file_if_missing $config_file run 644 v

    cat <<-. >> $pp_destdir$config_file

	# Controls whether the $svc service is started
	$sd_config_var=$sd_config_value
.

    if test ! -f $pp_destdir$scriptpath; then
    cat <<-. > $pp_destdir$scriptpath
	#!/sbin/sh
	# generated by pp $pp_version

	svc="$svc"
	pidfile="$pidfile"
	config_file="$config_file"

	pp_start () {
	    $cmd
	}

	pp_disabled () {
	    test \${$sd_config_var:-0} -eq 0
	}

	pp_stop () {
	    if test ! -s "$pidfile"; then
		echo "Unable to stop $svc (no pid file)"
		return 1
	    else
		read pid < "$pidfile"
		if kill -0 "$pid" 2>/dev/null; then
		    if kill -${stop_signal:-TERM} "$pid"; then
			rm -f "$pidfile"
			return 0
		    else
			echo "Unable to stop $svc"
			return 1
		    fi
		else
		    rm -f "$pidfile"
		    return 0
		fi
	    fi
	}

	pp_running () {
	    if test ! -s "$pidfile"; then
		return 1
	    else
		read pid < "$pidfile"
		kill -0 "$pid" 2>/dev/null
	    fi
	}

	case $1 in
	    start_msg) echo "Starting the $svc service";;
	    stop_msg)  echo "Stopping the $svc service";;
	    start)
		    if test -f "$config_file"; then
			. $config_file
		    fi
		    if pp_disabled; then
			exit 2
		    elif pp_running; then
			echo "$svc already running";
			exit 0
		    elif pp_start; then
			echo "$svc started";
			# rc(1M) says we should exit 4, but nobody expects it!
			exit 0
		    else
			exit 1
		    fi;;
	    stop)   if pp_stop; then
			echo "$svc stopped";
			exit 0
		    else
			exit 1
		    fi;;
	    *) echo "usage: $0 {start|stop|start_msg|stop_msg}"
	       exit 1;;
	esac
.
    fi
}

#@ pp_sd_make_service($svc): create the service files and links
pp_sd_make_service () {
        typeset level startpriority stoppriority startlevels stoplevels
        typeset svc svcvar

        svc="$1"
	svcvar=`pp_makevar $svc`

        # TODO: Figure out why this check is here
        #-- don't do anything if the script exists
        #if test -s "$pp_destdir/sbin/init.d/$svc"; then
        #    pp_error "$pp_destdir/sbin/init.d/$svc exists"
        #    return
        #fi

        # symlink the script, depending on the priorities chosen
        eval startpriority='${pp_sd_startpriority_'$svcvar'}'
        eval stoppriority='${pp_sd_stoppriority_'$svcvar'}'
        test -z "$startpriority" && startpriority="${pp_sd_startpriority:-50}"
        test -z "$stoppriority" && stoppriority="${pp_sd_stoppriority:-50}"

        eval startlevels='${pp_sd_startlevels_'$svcvar'}'
        test -z "$startlevels" && startlevels="$pp_sd_startlevels"

        eval stoplevels='${pp_sd_stoplevels_'$svcvar'}'
        test -z "$stoplevels" && stoplevels="$pp_sd_stoplevels"

        # create the script and config file
        pp_sd_service_script $svc

        # fix the priority up
        case "$startpriority" in
            ???) :;;
            ??) startpriority=0$startpriority;;
            ?) startpriority=00$startpriority;;
        esac
        case "$stoppriority" in
            ???) :;;
            ??) stoppriority=0$stoppriority;;
            ?) stoppriority=00$stoppriority;;
        esac

        if test x"$stoplevels" = x"auto"; then
            stoplevels=
            test -z "$startlevels" || for level in $startlevels; do
                stoplevels="$stoplevels `expr $level - 1`"
            done
        fi

        # create the symlinks
        test -z "$startlevels" || for level in $startlevels; do
            echo "                file -t s" \
                    "/sbin/init.d/$svc" \
                    "/sbin/rc$level.d/S$startpriority$svc"
        done
        test -z "$stoplevels" || for level in $stoplevels; do
            echo "                file -t s" \
                    "/sbin/init.d/$svc" \
                    "/sbin/rc$level.d/K$stoppriority$svc"
        done
}

#@ pp_sd_control (name files...) creates and emits a control script
#  based on section "Control Script Format" in [1]
pp_sd_control () {
    typeset ctrl script
    typeset cpt

    ctrl="$1"; shift
    cpt="$1"; shift
    script="$pp_wrkdir/control.$ctrl.$cpt"
    cat <<. >$script
#! /sbin/sh
########
# Product: $name
# $ctrl
# Generated from $pp_opt_input by pp
########
#
# ${copyright:-(no copyright information)}
#
########
.
    cat "$@" >> $script
    echo "exit 0" >> $script
    /usr/bin/chmod +x $script
    echo "                $ctrl $script"
}

#@ pp_backend_sd(): processes output files to generate a package files
pp_backend_sd () {
    typeset psf cpt svc outfile

    psf=$pp_wrkdir/psf

    echo "depot" > $psf
    echo "layout_version 1.0" >>$psf

    #-- vendor
    cat <<. >>$psf
        vendor
            tag             $pp_sd_vendor_tag
            title           "${pp_sd_vendor:-$vendor}"
        end

        product
            tag             $name
            revision        $version
            vendor_tag      $pp_sd_vendor_tag
            is_patch        false
            title           "$summary"
            copyright       "$copyright"
            machine_type    *
            os_name         HP-UX
            os_release      ?.11.*
            os_version      ?
            directory       /
            is_locatable    false
.
    test -n "$description" \
        && echo $description > $pp_wrkdir/description \
        && cat <<. >> $psf
            description     < $pp_wrkdir/description
.

    # make convenience service groups
    if test -n "$pp_service_groups"; then
	for grp in $pp_service_groups; do
	    pp_sd_service_group_script \
		$grp "`pp_service_get_svc_group $grp`"
	done
    fi

    for cpt in $pp_components; do
        cat <<. >>$psf
            fileset
                tag             ${pp_sd_fileset_tag:-$cpt}
                title           "${summary:-cpt}"
                revision        $version
.

	#-- make sure services are shut down during uninstall
        if test $cpt = run -a -n "$pp_services"; then
            for svc in $pp_services; do
                pp_prepend $pp_wrkdir/%preun.$cpt <<-.
			/sbin/init.d/$svc stop
.
            done
        fi

        #-- we put the post/preun code into configure/unconfigure
        # and not postinstall/preremove, because configure/unconfigure
        # scripts are run on the hosts where the package is installed,
        # not loaded (a subtle difference).
        test -s $pp_wrkdir/%pre.$cpt &&
            pp_sd_control checkinstall $cpt $pp_wrkdir/%pre.$cpt >> $psf
        test -s $pp_wrkdir/%post.$cpt &&
            pp_sd_control configure $cpt $pp_wrkdir/%post.$cpt >> $psf
        test -s $pp_wrkdir/%preun.$cpt &&
            pp_sd_control unconfigure $cpt $pp_wrkdir/%preun.$cpt >> $psf
        test -s $pp_wrkdir/%postun.$cpt &&
            pp_sd_control postremove $cpt $pp_wrkdir/%postun.$cpt >> $psf
        test -s $pp_wrkdir/%check.$cpt &&
            pp_sd_control checkinstall $cpt $pp_wrkdir/%check.$cpt >> $psf

        if test $cpt = run -a -n "$pp_services"; then
            for svc in $pp_services; do
                #-- service names are 10 chars max on hpux
                case "$svc" in ???????????*)
                    pp_warn "service name '$svc' is too long for hpux";;
                esac
                pp_sd_make_service $svc >> $psf
            done
            #pp_sd_make_service_config
        fi

        pp_sd_write_files < $pp_wrkdir/%files.$cpt >> $psf

        #-- end fileset clause
        cat <<. >>$psf
            end
.

    done

    #-- end product clause
    cat <<. >>$psf
        end
.

    $pp_opt_debug && cat $psf >&2

    test -s $pp_wrkdir/%fixup && . $pp_wrkdir/%fixup

    outfile=`pp_backend_sd_names`
    if pp_verbose ${pp_sd_sudo} /usr/sbin/swpackage \
        -s $psf \
        -x run_as_superuser=false \
        -x media_type=tape \
        @ $pp_wrkdir/$outfile
    then
        pp_verbose ${pp_sd_sudo} /usr/sbin/swlist -l file -s $pp_wrkdir/$outfile
    else
        pp_error "swpackage failed"
    fi
}

#@ pp_backend_sd_cleanup(): removes any files created outside $pp_wrkdir
pp_backend_sd_cleanup () {
    :
}

#@ pp_backend_sd_names(): prints the paths to package files
#    each path should start with $name-$version
#    the package must be relative to the $pp_wrkdir directory
pp_backend_sd_names () {
    echo "$name-$version.$pp_sd_arch_std.depot"
}

#@ pp_backend_sd_install_script(): generate a helper install script
pp_backend_sd_install_script () {
    typeset pkgname platform

    pkgname=`pp_backend_sd_names`
    platform="`pp_backend_sd_probe`"

    echo "#!/bin/sh"
    pp_install_script_common
    cat <<.

        cpt_to_tags () {
            test x"\$*" = x"all" && set -- $pp_components
            for cpt
            do
                echo "$name.\$cpt"
            done
        }

        test \$# -eq 0 && usage
        op="\$1"; shift

        case "\$op" in
            list-components)
                test \$# -eq 0 || usage \$op
                echo "$pp_components"
                ;;
            list-services)
                test \$# -eq 0 || usage \$op
                echo "$pp_services"
                ;;
            list-files)
                test \$# -ge 1 || usage \$op
                echo \${PP_PKGDESTDIR:-.}/$pkgname
                ;;
            install)
                test \$# -ge 1 || usage \$op
                verbose /usr/sbin/swinstall -x verbose=0 \
                    -s \${PP_PKGDESTDIR:-\`pwd\`}/$pkgname \
                    \`cpt_to_tags "\$@"\`
                ;;
            uninstall)
                test \$# -ge 1 || usage \$op
                verbose /usr/sbin/swremove -x verbose=0 \
                    \`cpt_to_tags "\$@"\`
                ;;
            start|stop)
                test \$# -ge 1 || usage \$op
                ec=0
                for svc
                do
                    verbose /sbin/init.d/\$svc \$op
                    [ \$? -eq 4 -o \$? -eq 0 ] || ec=1
                done
                exit \$ec
                ;;
            print-platform)
		echo "$platform"
		;;
            *)
                usage
                ;;
        esac
.
}

#@ pp_backend_sd_probe() : detect local platform name
pp_backend_sd_probe () {
    echo "${pp_sd_os_std}-${pp_sd_arch_std}"
}

#@ pp_backend_sd_vas_platforms() : print the equivalent VAS platforms
pp_backend_sd_vas_platforms () {
    case "`pp_backend_sd_probe`" in
	hpux*-hppa) echo hpux-pa;;
	hpux*-ia64) echo hpux-ia64 hpux-pa;;
	*)	    pp_die "unknown system `pp_backend_sd_probe`";;
    esac
}

#@ pp_backend_sd_init_svc_vars(): initialise service vars
pp_backend_sd_init_svc_vars () {
    :
}
