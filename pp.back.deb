# Debian backend

pp_platforms="$pp_platforms deb"

#@ pp_backend_deb_detect(uname_s): return true if matches uname on deb
pp_backend_deb_detect () {
    test -f /etc/debian_version
}

#@ pp_backend_deb_init(): initialises platform variables for deb 
pp_backend_deb_init () {
    :
}

#@ pp_deb_makedeb(out controlfile...): create a debian file
pp_deb_makedeb () {
    typeset outfile
    typeset _l t m o g f p st

    outfile="$1"; shift

    echo 2.0 > $pp_wrkdir/debian-binary || return
    ar cv $outfile $pp_wrkdir/debian-binary || return
    rm -f $pp_wrkdir/debian-binary 

    # add control files from the argument list
    if test $# -gt 0; then
	tar -C $pp_wrkdir -z -f $pp_wrkdir/control.tar.gz "$@" || return
	ar u $outfile $pp_wrkdir/control.tar.gz || return
	rm -f $pp_wrkdir/control.tar.gz
    fi

    # add data files from on stdin, relative to pp_destdir
    while read t m o g f p st; do
        case "$t" in
	    *) :;;  # XXX this won't work - need to 'hand create' the tar
	esac
    done |
    tar -C $pp_destdir -z -f $pp_wrkdir/data.tar.gz \
	-T - || return
    ar u $outfile $pp_wrkdir/data.tar.gz || return
    rm -f $pp_wrkdir/data.tar.gz
}

#@ pp_backend_deb(): processes output files to generate a package files
pp_backend_deb () {
    typeset debname

    debname=`pp_backend_deb_names`

    debian-binary
    control.tar.gz
    data.tar.gz
}

#@ pp_backend_deb_cleanup(): removes any files created outside $pp_wrkdir
pp_backend_deb_cleanup () {
    :
}

#@ pp_backend_deb_names(): prints the paths to package files
#    each path should start with $name-$version
#    the package must be relative to the $pp_wrkdir directory
pp_backend_deb_names () {
    :
}

#@ pp_backend_deb_install_script(): generate a helper install script
pp_backend_deb_install_script () {
    pp_error unimplemented
}

#@ pp_backend_deb_function(): output a platform-dependent function
pp_backend_deb_function() {
    case "$1" in
        pp_mkuser)
            pp_error unimplemented;;
        pp_mkgroup)
            pp_error unimplemented;;
        pp_havelib)
            pp_error unimplemented;;
        *)
            pp_error "unknown function request: $1";;
    esac
}

#@ pp_backend_deb_init_svc_vars(): initialise service vars
pp_backend_deb_init_svc_vars() {
    :
}

#@ pp_backend_deb_probe(): output local platform's short id
pp_backend_deb_probe() {
    typeset arch distro release

    arch=`uname -m`
    # i486/i586/i686 processors (usually) produce i386 binaries
    case $arch in
    	i*86)
	    arch=i386
	;;
    esac

    # /etc/debian_version exists on Debian & Ubuntu, so it's no use
    # to us. Use lsb_release instead.
    if [ ! lsb_release > /dev/null ]; then
        echo unknown-$arch
        return 0
    fi

    case `lsb_release -is` in
        Debian)
            distro=deb
        ;;
        Ubuntu)
            distro=ubu
        ;;
        *)
            distro=unknown
        ;;
    esac

    release=`lsb_release -rs`

    # If release is not numeric, use the codename
    case $release in
        [0-9]*.[0-9]*)
	;;
	*)
	    release=`lsb_release -cs`
	;;
    esac

    echo $distro$release-$arch
}
