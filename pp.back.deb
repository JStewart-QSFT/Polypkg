# Debian backend

pp_platforms="$pp_platforms deb"

#@ pp_backend_deb_detect(uname_s): return true if matches uname on deb
pp_backend_deb_detect () {
    test -f /etc/debian_version
}

#@ pp_deb_cmp_full_name(component hyphen): translate cpt into a linux subpackage name
pp_deb_cmp_full_name () {
    typeset prefix
    prefix="${pp_deb_name:-$name}"
    case "$1" in
        run) echo "${prefix}" ;;
        dbg) echo "${prefix}-${pp_deb_dbg_pkgname}";;
        dev) echo "${prefix}-${pp_deb_dev_pkgname}";;
        doc) echo "${prefix}-${pp_deb_doc_pkgname}";;
        *)   pp_error "unknown component '$1'";
    esac
}

#@ pp_backend_deb_init(): initialises platform variables for deb 
pp_backend_deb_init () {
    pp_deb_dpkg_version="2.0"
    pp_deb_name=
    pp_deb_version=
    pp_deb_release=
    pp_deb_arch=`pp_deb_detect_arch`
    pp_deb_maintainer=
    pp_deb_copyright=
    pp_deb_distro=
    pp_deb_control_description=
    pp_deb_summary=
    pp_deb_description=
    pp_deb_dbg_pkgname="dbg"
    pp_deb_dev_pkgname="dev"
    pp_deb_doc_pkgname="doc"
    pp_deb_section=contrib # Free software that depends on non-free software

    # Make sure any programs we require are installed
    pp_deb_check_required_programs

    # Set generated/interrogated platforms variables
    pp_deb_munge_description
}

#@ pp_deb_detectarch: detect the architecture and set pp_deb_arch
pp_deb_check_required_programs () {
    typeset not_found required prog
    not_found=
    required="dpkg dpkg-deb install md5sum fakeroot dh_link"
    for prog in ${required}
    do
        test -x `which $prog` || not_found="${not_found} ${prog}"
    done

    if [ x"$not_found" != x ]
    then
        echo "ERROR: The following required programs could not be found:${not_found}"
        exit 1 
    fi
}

#@ pp_deb_munge_description: convert the description to a format that is control file friendly
pp_deb_munge_description () {
    # Insert a leading space on each line, replace blank lines with a space followed by a full-stop.
    pp_deb_control_description=`echo ${pp_deb_description:-$description} | \
        sed "s,^\(.*\)$, \1, " \
        | sed "s,^[ \t]*$, .,g"`

}

#@ pp_deb_detectarch: detect the architecture and set pp_deb_arch
pp_deb_detect_arch () {
   dpkg --print-architecture
}

#@ pp_deb_makecontrol(name): create a debian control file
pp_deb_make_control() {
    typeset controlfile cmp package_name
    cmp="$1"
    controlfile="$2"
    package_name=`pp_deb_cmp_full_name $cmp`
cat<<EOF>$controlfile || exit 1
Package: ${package_name}
Version: ${pp_deb_version:-$version}-${pp_deb_release:-1}
Section: ${pp_deb_section:-contrib}
Priority: optional
Architecture: ${pp_deb_arch}
Maintainer: ${pp_deb_maintainer:-$maintainer} 
Description: ${pp_deb_summary:-$summary}
${pp_deb_control_description}
EOF
}

#@ pp_deb_make_md5sums(data_dir, output) create md5sums for data files
# files are relative to pp_wrkdir/data
pp_deb_make_md5sums() {
    typeset cmp=$1; shift
    typeset pkg_dir
    pkg_dir=$pp_wrkdir/`pp_deb_cmp_full_name $cmp`
    (cd $pkg_dir; md5sum "$@" > $pkg_dir/DEBIAN/md5sums ) || exit 1
}

#@ pp_deb_make_package_maintainer_script(output, source, description): create package maintainer script
pp_deb_make_package_maintainer_script() {
    typeset output="$1"
    typeset source="$2"
    typeset desc="$3"

    # See if we need to create this script at all
    if [ -f $source ] 
    then

        # Create header 
        cat<<EOF>$output || exit 1
#!/bin/sh
# $desc 
# Generated by Poly Package

EOF
        test $? -eq 0 || exit 1

        cat $source >> "$output"
 
        # Set perms
        chmod 755 "$output" || exit 1
    fi
}

#@ pp_deb_handle_services: handle services and append appropriate stuff to postinst/prerm
pp_deb_handle_services() {
    #-- add service start/stop code
    if test -n "$pp_services"; then
        #-- record the uninstall commands in reverse order
        for svc in $pp_services; do
            pp_load_service_vars $svc

            # Create init script (unless one exists)
            pp_deb_service_make_init_script $svc

            # Make sure the init script is marked as a conffile
            echo "/etc/init.d/$svc" >> $pp_wrkdir/%conffiles.run

            #-- append %post code to install the svc
            echo "update-rc.d $svc defaults" >> $pp_wrkdir/%post.run

            #-- prepend %preun code to stop svc
            test -f $pp_wrkdir/%preun.run || echo "#!/bin/sh" > $pp_wrkdir/%preun.run
            cat<<EOF | pp_prepend $pp_wrkdir/%preun.run
    if which invoke-rc.d >/dev/null 2>&1; then
        invoke-rc.d $svc stop
    else
        /etc/init.d/$svc stop
    fi
EOF
            #-- prepend %postun code to uninstall svc
            test -f $pp_wrkdir/%postun.run || echo "#!/bin/sh" > $pp_wrkdir/%postun.run
            cat<<EOF | pp_prepend $pp_wrkdir/%postun.run
if [ "\$1" = purge ]; then
    update-rc.d $svc remove
fi
EOF
        done
        #pp_deb_service_remove_common | pp_prepend $pp_wrkdir/%preun.run
    fi

}

#@ pp_deb_make_DEBIAN(): create control files
pp_deb_make_DEBIAN() {
    typeset cmp="${1:-run}"
    typeset data cmp_full_name
    cmp_full_name=`pp_deb_cmp_full_name $cmp`
    data=$pp_wrkdir/$cmp_full_name

    # Create DEBIAN dir $data/DEBIAN
    mkdir -p $data/DEBIAN

    # Create control file
    pp_deb_make_control $cmp $data/DEBIAN/control || exit $?

    # Copy in conffiles
    test -f $pp_wrkdir/%conffiles.$cmp && cp $pp_wrkdir/%conffiles.$cmp $data/DEBIAN

    # Create postinst
    pp_deb_make_package_maintainer_script "$data/DEBIAN/postinst" \
        "$pp_wrkdir/%post.$cmp" "Post install script for $cmp_full_name"\
        || exit $?

    # Create prerm
    pp_deb_make_package_maintainer_script "$data/DEBIAN/prerm" \
        "$pp_wrkdir/%preun.$cmp" "Pre-uninstall script for $cmp_full_name"\
        || exit $?

    # Create postrm
    pp_deb_make_package_maintainer_script "$data/DEBIAN/postrm" \
        "$pp_wrkdir/%postun.$cmp" "Post uninstall script for $cmp_full_name"\
        || exit $?
}

#@ pp_deb_make_data(name): Package up data files for .deb
pp_deb_make_data() {
    typeset _l t m o g f p st data
    typeset data share_doc 
    cmp=$1
    data=$pp_wrkdir/`pp_deb_cmp_full_name $cmp`
    cat $pp_wrkdir/%files.${cmp} | while read t m o g f p st; do
        case "$t" in
        # TODO owner/group
        f) # Files 
           install -D -m ${m} $pp_destdir/$p $data/$p;
           if [ x$f = xv ]
           then
               # File marked as "volatile". Assume this means it's a conffile
               echo "$p" >> $pp_wrkdir/%conffiles.$cmp
           fi;;

        d) # Directories 
           install -m ${m} -d $data/$p;;

        s) # Symlinks 
           # Remove leading / from vars
           rel_p=`echo $p | sed s,^/,,`
           rel_st=`echo $st | sed s,^/,,`
           # TODO: we are always doing absolute links here. We should follow the
           # debian policy of relative links when in the same top-level directory
           (cd $data; ln -sf $st $rel_p);;
	    *) echo Unsupported data file type "$t"; exit 1;; 
	esac
    done 

    # If no copyright file is present add one. This is a debian requirement.
    share_doc="/usr/share/doc/`pp_deb_cmp_full_name $cmp`"
    if [ ! -f "$data/$share_doc/copyright" ]
    then
        echo "${pp_deb_copyright:-$copyright}" > "$pp_wrkdir/copyright"
        install -D -m 644 "$pp_wrkdir/copyright" "$data/$share_doc/copyright" 
    fi

}

#@ pp_deb_makedeb(out controlfile...): create a debian file
pp_deb_makedeb () {
    typeset output deb_files cmp
    typeset package_build_dir

    cmp="$1";
    output="$2";

    pp_debug "Making $output..."

    package_build_dir=$pp_wrkdir/`pp_deb_cmp_full_name $cmp`
        
    # Create package dir
    mkdir -p $package_build_dir

    # Make control files
    pp_deb_make_DEBIAN $cmp || { echo "Could not make DEBIAN control files"; exit 1; }

    # Copy in data
    pp_deb_make_data $cmp || { echo "Could not make data"; exit 1; }

    # Create md5sums
    pp_deb_make_md5sums $cmp `(cd $package_build_dir; find . -type f -a -not -name DEBIAN | sed "s,^\./,,")` || exit $?

    # Create debian package
    pp_debug "Building `pp_deb_cmp_full_name $cmp` -> $output"
    dpkg-deb --build $package_build_dir $output
}

#@ pp_backend_deb(): processes output files to generate a package files
pp_backend_deb () {
    typeset debname

    # Handle services
    pp_deb_handle_services $cmp || exit $?

    for cmp in $pp_components
    do
        debname=`pp_deb_name $cmp`
        pp_deb_makedeb $cmp $pp_wrkdir/$debname || exit $?
    done
}

#@ pp_backend_deb_cleanup(): removes any files created outside $pp_wrkdir
pp_backend_deb_cleanup () {
    # rm -rf $pp_wrkdir
    :
}

#@ pp_deb_name(component): prints the names of the package files
pp_deb_name () {
    typeset cmp="${1:-run}"
    echo `pp_deb_cmp_full_name $cmp`"-${pp_deb_version:-$version}-${pp_deb_release:-1}.${pp_deb_arch:-$arch}.deb"
}
#
#@ pp_backend_deb_names: prints the names of the package files
pp_backend_deb_names () {
    for cmp in $pp_components
    do
        pp_deb_name $cmp
    done
}

#@ pp_backend_deb_install_script(): generate a helper install script
pp_backend_deb_install_script () {
    typeset cmp _cmp_full_name

    echo "#!/bin/sh"
    pp_install_script_common

    cat <<.

        cmp_to_pkgname () {
            test x"\$*" = x"all" && 
                set -- $pp_components
            for cmp
            do
                case \$cmp in
.
    for cmp in $pp_components; do
        _cmp_full_name=`pp_deb_cmp_full_name $cmp -`
         echo "$cmp) echo ${_cmp_full_name};;"
    done
    cat <<.
                *) usage;;
                esac
            done
        }


        cmp_to_pathname () {
            test x"\$*" = x"all" && 
                set -- $pp_components
            for cmp
            do
                case \$cmp in
.
    for cmp in $pp_components; do
        _cmp_full_name=`pp_deb_cmp_full_name $cmp`
        echo "$cmp) echo \${PP_PKGDESTDIR:-.}/${_cmp_full_name}-${pp_deb_version:-$version}-${pp_deb_release:-1}.${pp_deb_arch}.deb;;"
    done
    cat <<.
                *) usage;;
                esac
            done
        }


        test \$# -eq 0 && usage
        op="\$1"; shift
        case "\$op" in
            list-components) 
                test \$# -eq 0 || usage \$op
                echo $pp_components
                ;;
            list-services)
                test \$# -eq 0 || usage \$op
                echo $pp_services
                ;;
            list-files)
                test \$# -ge 1 || usage \$op
                cmp_to_pathname "\$@"
                ;;
            install)
                test \$# -ge 1 || usage \$op
                dpkg --install \`cmp_to_pathname "\$@"\`
                ;;
            uninstall)
                test \$# -ge 1 || usage \$op
                dpkg --remove \`cmp_to_pkgname "\$@"\`
                ;;
            start|stop)
                test \$# -ge 1 || usage \$op
                ec=0
                for svc
                do
                    /etc/init.d/\$svc \$op || ec=1
                done
                exit \$ec
                ;;
            print-platform)
                test \$# -eq 0 || usage \$op
		echo "linux-${pp_deb_arch}"
		;;
            *)
                usage
                ;;
        esac
.
}

#@ pp_backend_deb_function(): output a platform-dependent function
pp_backend_deb_function() {

    case "$1" in
        pp_mkgroup) 
            cat<<'.';;
            /usr/sbin/groupadd -r $1
.
        pp_mkuser) 
            cat<<'.';;
            /usr/sbin/useradd -s /bin/false -M -r $@ 
.
        pp_havelib) cat<<'.';;
            typeset dir
            for dir in `echo "/usr/lib:/lib${3+:$3}" | tr : ' '`; do
                test -r "$dir/lib$1.so{$2+.$2}" && return 0
            done
            return 1
.
        *)
            pp_error "unknown function request: $1";;
    esac
}

#@ pp_backend_deb_probe(): output local platform's short id
pp_backend_deb_probe() {
    typeset arch distro release

    arch=`pp_deb_detect_arch`

    # /etc/debian_version exists on Debian & Ubuntu, so it's no use
    # to us. Use lsb_release instead.
    if [ ! lsb_release > /dev/null ]; then
        echo unknown-$arch
        return 0
    fi

    case `lsb_release -is` in
        Debian)
            distro=deb
        ;;
        Ubuntu)
            distro=ubu
        ;;
        *)
            distro=unknown
        ;;
    esac

    release=`lsb_release -rs`

    # If release is not numeric, use the codename
    case $release in
        [0-9]*.[0-9]*)
            release=`echo $release | tr -d .`
	;;
	*)
	    release=`lsb_release -cs`
	;;
    esac

    echo $distro$release-$arch
}

