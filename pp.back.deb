# Debian backend

pp_platforms="$pp_platforms deb"

myexit () {
 echo "Wanting to exit with $1"
 exit $1
}

#alias exit=myexit

#@ pp_backend_deb_detect(uname_s): return true if matches uname on deb
pp_backend_deb_detect () {
    test -f /etc/debian_version
}

#@ pp_backend_deb_init(): initialises platform variables for deb 
pp_backend_deb_init () {
    pp_deb_dpkg_version="2.0"
    pp_deb_name=
    pp_deb_version=
    pp_deb_release=
    pp_deb_arch=`pp_deb_detect_arch`
    pp_deb_maintainer=
    pp_deb_copyright=
    pp_deb_distro=
    pp_deb_control_description=
    pp_deb_summary=
    pp_deb_description=
    pp_deb_section=contrib # Free software that depends on non-free software

    # Make sure any programs we require are installed
    pp_deb_check_required_programs

    # Set generated/interrogated platforms variables
    pp_deb_munge_description
}

#@ pp_deb_detectarch: detect the architecture and set pp_deb_arch
pp_deb_check_required_programs () {
    typeset not_found required prog
    not_found=
    required="dpkg ar tar install md5sum fakeroot"
    for prog in ${required}
    do
        test -x `which $prog` || not_found="${not_found} ${prog}"
    done

    if [ x"$not_found" != x ]
    then
        echo "ERROR: The following required programs could not be found:${not_found}"
        exit 1 
    fi
}

#@ pp_deb_munge_description: convert the description to a format that is control file friendly
pp_deb_munge_description () {
    # Insert a leading space on each line, replace blank lines with a space followed by a full-stop.
    pp_deb_control_description=`echo ${pp_deb_description:-$description} | \
        sed "s,^\(.*\)$, \1, " \
        | sed "s,^[ \t]*$, .,g"`

}

#@ pp_deb_detectarch: detect the architecture and set pp_deb_arch
pp_deb_detect_arch () {
   dpkg --print-architecture
}

#@ pp_deb_makecontrol(name): create a debian control file
pp_deb_make_control() {
    typeset controlfile
    controlfile="$1"
cat<<EOF>$controlfile || exit 1
Package: ${pp_deb_name:-$name}
Version: ${pp_deb_version:-$version}-${pp_deb_release:-1}
Section: ${pp_deb_section:-contrib}
Priority: optional
Architecture: ${pp_deb_arch}
Maintainer: ${pp_deb_maintainer:-$maintainer} 
Description: ${pp_deb_summary:-$summary}
${pp_deb_control_description}
EOF
}

#@ pp_deb_make_md5sums(name, files...): create md5sums for data files
# files are relative to pp_wrkdir/data
pp_deb_make_md5sums() {
    typeset output
    output=$1; shift
    (cd $pp_wrkdir/data; md5sum "$@" > $output ) || exit 1
}

#@ pp_deb_make_postinst(name): create postinst file
pp_deb_make_postinst() {
    typeset postinst
    postinst="$1"
    # TODO: Autodetect whether we actually need to generate a postinstall script
    # Create postinst header
    cat<<EOF>$postinst || exit 1
#!/bin/sh
# Post-install script for ${pp_deb_name:-name}
# Autogenerated by Poly Package

EOF
  # Add package post install if any 
  if [ -f $pp_wrkdir/%post.run ]
  then
    echo "# Package post install" >> "$postinst"
    cat $pp_wrkdir/%post.run >> "$postinst"
  fi

  # Add symlinks if any
  if [ -f $pp_wrkdir/postinst-links ]
  then
    echo "# Create symlinks" >> "$postinst"
    cat $pp_wrkdir/postinst-links >> "$postinst"
    rm $pp_wrkdir/postinst-links
  fi

  # Set perms and attempt to set owner/group
  chmod 755 "$postinst" || exit 1
}

#@ pp_deb_make_prerm(name): create prerm file
pp_deb_make_prerm() {
    typeset prerm
    prerm="$1"
    echo "Entering prerm"
    # TODO: Autodetect whether we actually need to generate a prermall script
    # Create prerm header
    cat<<EOF>$prerm || exit 1
#!/bin/sh
# Pre-uninstall script for ${pp_deb_name:-name}
# Autogenerated by Poly Package

EOF
  test $? -eq 0 || exit 1

  # Add package pre uninstall if any 
  if [ -f $pp_wrkdir/%preun.run ]
  then
    echo "# Package prerm" >> "$prerm"
    cat $pp_wrkdir/%preun.run >> "$prerm"
  fi
 
  # Add symlinks if any
  if [ -f $pp_wrkdir/prerm-links ]
  then
    echo "# Create symlinks" >> $prerm
    cat $pp_wrkdir/prerm-links >> $prerm
  fi
  rm $pp_wrkdir/prerm-links

  # Set perms and attempt to set owner/group
  chmod 755 "$prerm" || exit 1
}

#@ pp_deb_make_control_tgz(files ): create control files
pp_deb_make_control_tgz() {
    typeset control_tgz control_files


    # Get list of files to md5sum
    control_tgz=$1

    # Create control file
    pp_deb_make_control $pp_wrkdir/control #|| exit $?

    # Create md5sum
    pp_deb_make_md5sums $pp_wrkdir/md5sums `(cd $pp_wrkdir/data; find . -type f | sed "s,^\./,,")` || exit $?

    # Create postinst
    pp_deb_make_postinst "$pp_wrkdir/postinst" || exit $?

    # Create prerm
    pp_deb_make_prerm "$pp_wrkdir/prerm" || exit $?

    # Make sure mandatory files are present
    test -f $pp_wrkdir/control || { echo "ERROR: Mandatory file 'control' not created"; exit 1; }
    test -f $pp_wrkdir/md5sums || { echo "ERROR: Mandatory file 'md5sums' not created"; exit 1; }

    # Get control files
    control_files="control md5sums"
    test -f $pp_wrkdir/postinst && control_files="${control_files} postinst"
    test -f $pp_wrkdir/prerm && control_files="${control_files} prerm"
    test -f $pp_wrkdir/conffiles && control_files="${control_files} conffiles"

	(cd $pp_wrkdir; fakeroot tar -zcf $control_tgz $control_files ) || { echo "ERROR: Could not create control.tar.gz"; exit 1; } 
}

#@ pp_deb_make_data_tgz(name): Package up data files for .deb
pp_deb_make_data_tgz() {
    typeset _l t m o g f p st data
    typeset data_tgz data share_doc 
    data_tgz=$1
    data=$pp_wrkdir/data
    mkdir "$data"
    cat $pp_wrkdir/%files.* | while read t m o g f p st; do
        case "$t" in
        # TODO owner/group
        f) install -D -m ${m} $pp_destdir/$p $data/$p;
           if [ x$f = xv ]
           then
               # File marked as "volatile". Assume this means it's a conffile
               echo "$p" >> $pp_wrkdir/conffiles
           fi;;
        d) install -m ${m} -d $data/$p;;
        s) # Do symlinks in post install
           echo "ln -s $st $p" >> $pp_wrkdir/postinst-links;
           echo "rm -f $p" >> $pp_wrkdir/prerm-links;;
	    *) echo Unsupported data file type "$t"; exit 1;; 
	esac
    done 

    # If no copyright file is present add one. This is a debian requirement.
    share_doc="/usr/share/doc/${pp_deb_name:-$name}"
    if [ ! -f "$data/$share_doc/copyright" ]
    then
        echo "${pp_deb_copyright:-$copyright}" > "$pp_wrkdir/copyright"
        install -D -m 644 "$pp_wrkdir/copyright" "$data/$share_doc/copyright" 
    fi

    ( cd $data; fakeroot tar -zcvf $data_tgz .) || exit 1
}

#@ pp_deb_makedeb(out controlfile...): create a debian file
pp_deb_makedeb () {
    typeset outfile deb_files

    outfile="$1"; shift

    # Create debian files
    echo $pp_deb_dpkg_version > $pp_wrkdir/debian-binary || exit $? 
    pp_deb_make_data_tgz $pp_wrkdir/data.tar.gz || exit $? 
    pp_deb_make_control_tgz $pp_wrkdir/control.tar.gz || exit $?

    # Create debian package from debian-binary, control.tar.gz and data.tar.gz
    deb_files="$pp_wrkdir/debian-binary $pp_wrkdir/control.tar.gz $pp_wrkdir/data.tar.gz"
    ar cruv $outfile $deb_files || { echo "ERROR: Could not create $output"; exit 1; }
    rm -f $deb_files
}

#@ pp_backend_deb(): processes output files to generate a package files
pp_backend_deb () {
    typeset debname

    debname=`pp_backend_deb_names`
    pp_deb_makedeb $pp_wrkdir/$debname || exit $?
}

#@ pp_backend_deb_cleanup(): removes any files created outside $pp_wrkdir
pp_backend_deb_cleanup () {
    # rm -rf $pp_wrkdir
    :
}

#@ pp_backend_deb_names(): prints the paths to package files
#    each path should start with $name-$version
#    the package must be relative to the $pp_wrkdir directory
pp_backend_deb_names () {
    echo "${pp_deb_name:-$name}${_subname}-${pp_deb_version:-$version}-${pp_deb_release:-1}.${pp_deb_arch:-$arch}.deb"
}

#@ pp_backend_deb_install_script(): generate a helper install script
pp_backend_deb_install_script () {
    pp_error unimplemented
}

#@ pp_backend_deb_function(): output a platform-dependent function
pp_backend_deb_function() {

    case "$1" in
        pp_mkgroup) 
            cat<<'.';;
            /usr/sbin/groupadd -r $1
.
        pp_mkuser) 
            cat<<'.';;
            /usr/sbin/useradd -s /bin/false -M -r $@ 
.
        pp_havelib) cat<<'.';;
            typeset dir
            for dir in `echo "/usr/lib:/lib${3+:$3}" | tr : ' '`; do
                test -r "$dir/lib$1.so{$2+.$2}" && return 0
            done
            return 1
.
        *)
            pp_error "unknown function request: $1";;
    esac
}

#@ pp_backend_deb_init_svc_vars(): initialise service vars
pp_backend_deb_init_svc_vars() {
    :
}

#@ pp_backend_deb_probe(): output local platform's short id
pp_backend_deb_probe() {
    typeset arch distro release

    arch=`pp_deb_detect_arch`

    # /etc/debian_version exists on Debian & Ubuntu, so it's no use
    # to us. Use lsb_release instead.
    if [ ! lsb_release > /dev/null ]; then
        echo unknown-$arch
        return 0
    fi

    case `lsb_release -is` in
        Debian)
            distro=deb
        ;;
        Ubuntu)
            distro=ubu
        ;;
        *)
            distro=unknown
        ;;
    esac

    release=`lsb_release -rs`

    # If release is not numeric, use the codename
    case $release in
        [0-9]*.[0-9]*)
            release=`echo $release | tr -d .`
	;;
	*)
	    release=`lsb_release -cs`
	;;
    esac

    echo $distro$release-$arch
}
