# Debian backend

pp_platforms="$pp_platforms deb"

#@ pp_backend_deb_detect(uname_s): return true if matches uname on deb
pp_backend_deb_detect () {
    test -f /etc/debian_version
}

#@ pp_backend_deb_init(): initialises platform variables for deb 
pp_backend_deb_init () {
    pp_deb_dpkg_version="2.0"
    pp_deb_name=
    pp_deb_version=
    pp_deb_release=
    pp_deb_arch=`pp_deb_detect_arch`
    pp_deb_maintainer=
    pp_deb_copyright=
    pp_deb_distro=
    pp_deb_control_description=
    pp_deb_summary=
    pp_deb_description=
    pp_deb_section=contrib # Free software that depends on non-free software

    # Make sure any programs we require are installed
    pp_deb_check_required_programs

    # Set generated/interrogated platforms variables
    pp_deb_munge_description
}

#@ pp_deb_detectarch: detect the architecture and set pp_deb_arch
pp_deb_check_required_programs () {
    typeset not_found required prog
    not_found=
    required="dpkg dpkg-deb install md5sum fakeroot dh_link"
    for prog in ${required}
    do
        test -x `which $prog` || not_found="${not_found} ${prog}"
    done

    if [ x"$not_found" != x ]
    then
        echo "ERROR: The following required programs could not be found:${not_found}"
        exit 1 
    fi
}

#@ pp_deb_munge_description: convert the description to a format that is control file friendly
pp_deb_munge_description () {
    # Insert a leading space on each line, replace blank lines with a space followed by a full-stop.
    pp_deb_control_description=`echo ${pp_deb_description:-$description} | \
        sed "s,^\(.*\)$, \1, " \
        | sed "s,^[ \t]*$, .,g"`

}

#@ pp_deb_detectarch: detect the architecture and set pp_deb_arch
pp_deb_detect_arch () {
   dpkg --print-architecture
}

#@ pp_deb_makecontrol(name): create a debian control file
pp_deb_make_control() {
    typeset controlfile
    controlfile="$1"
cat<<EOF>$controlfile || exit 1
Package: ${pp_deb_name:-$name}
Version: ${pp_deb_version:-$version}-${pp_deb_release:-1}
Section: ${pp_deb_section:-contrib}
Priority: optional
Architecture: ${pp_deb_arch}
Maintainer: ${pp_deb_maintainer:-$maintainer} 
Description: ${pp_deb_summary:-$summary}
${pp_deb_control_description}
EOF
}

#@ pp_deb_make_md5sums(name, files...): create md5sums for data files
# files are relative to pp_wrkdir/data
pp_deb_make_md5sums() {
    typeset output
    output=$1; shift
    (cd $pp_wrkdir/data; md5sum "$@" > $output ) || exit 1
}

#@ pp_deb_make_package_maintainer_script(output, source, description): create prerm file
pp_deb_make_package_maintainer_script() {
    typeset output="$1"
    typeset source="$2"
    typeset desc="$3"

    # See if we need to create this script at all
    test -f $source || exit 0

    # Create header 
    cat<<EOF>$output || exit 1
#!/bin/sh
# $desc 
# Generated by Poly Package

EOF
    test $? -eq 0 || exit 1

    cat $source >> "$output"
 
    # Set perms
    chmod 755 "$output" || exit 1
}

#@ pp_deb_handle_services: handle services and append appropriate stuff to postinst/prerm
pp_deb_handle_services() {
    #-- add service start/stop code
    if test -n "$pp_services"; then
        pp_deb_service_install_common >> $pp_wrkdir/%post.run

        #-- record the uninstall commands in reverse order
        for svc in $pp_services; do
            pp_load_service_vars $svc

            # Create init script (unless one exists)
            pp_deb_service_make_init_script $svc

            # Make sure the init script is marked as a conffile
            echo "/etc/init.d/$svc" >> $pp_wrkdir/conffiles 

            #-- append %post code to install the svc
            echo "update-rc.d $svc defaults" >> $pp_wrkdir/%post.run

            #-- prepend %preun code to uninstall svc
            test -f $pp_wrkdir/%postun.run || echo "#!/bin/sh" > $pp_wrkdir/%postun.run
            cat<<EOF | pp_prepend $pp_wrkdir/%postun.run
if [ "\$1" = purge ]; then
    update-rc.d $svc remove
fi
EOF
        done
        #pp_deb_service_remove_common | pp_prepend $pp_wrkdir/%preun.run
    fi

}

#@ pp_deb_make_DEBIAN(): create control files
pp_deb_make_DEBIAN() {
    # Create DEBIAN dir
    mkdir -p $pp_wrkdir/data/DEBIAN

    # Create control file
    pp_deb_make_control $pp_wrkdir/data/DEBIAN/control #|| exit $?


    # Create postinst
    pp_deb_make_package_maintainer_script "$pp_wrkdir/data/DEBIAN/postinst" \
        "$pp_wrkdir/%post.run" "Post install script for ${pp_deb_name:-$name}"\
        || exit $?

    # Create prerm
    pp_deb_make_package_maintainer_script "$pp_wrkdir/data/DEBIAN/prerm" \
        "$pp_wrkdir/%preun.run" "Pre-uninstall script for ${pp_deb_name:-$name}"\
        || exit $?
    #
    # Create postrm
    pp_deb_make_package_maintainer_script "$pp_wrkdir/data/DEBIAN/postrm" \
        "$pp_wrkdir/%postun.run" "Post uninstall script for ${pp_deb_name:-$name}"\
        || exit $?
}

#@ pp_deb_make_data(name): Package up data files for .deb
pp_deb_make_data() {
    typeset _l t m o g f p st data
    typeset data_tgz data share_doc 
    data_tgz=$1
    data=$pp_wrkdir/data
    cat $pp_wrkdir/%files.* | while read t m o g f p st; do
        case "$t" in
        # TODO owner/group
        f) # Files 
           install -D -m ${m} $pp_destdir/$p $data/$p;
           if [ x$f = xv ]
           then
               # File marked as "volatile". Assume this means it's a conffile
               echo "$p" >> $pp_wrkdir/conffiles
           fi;;

        d) # Directories 
           install -m ${m} -d $data/$p;;

        s) # Symlinks 
           # Remove leading / from vars
           rel_p=`echo $p | sed s,^/,,`
           rel_st=`echo $st | sed s,^/,,`
           # TODO: we are always doing absolute links here. We should follow the
           # debian policy of relative links when in the same top-level directory
           (cd $data; ln -sf $st $rel_p);;
	    *) echo Unsupported data file type "$t"; exit 1;; 
	esac
    done 

    # If no copyright file is present add one. This is a debian requirement.
    share_doc="/usr/share/doc/${pp_deb_name:-$name}"
    if [ ! -f "$data/$share_doc/copyright" ]
    then
        echo "${pp_deb_copyright:-$copyright}" > "$pp_wrkdir/copyright"
        install -D -m 644 "$pp_wrkdir/copyright" "$data/$share_doc/copyright" 
    fi

}

#@ pp_deb_makedeb(out controlfile...): create a debian file
pp_deb_makedeb () {
    typeset outfile deb_files

    outfile="$1"; shift

    # Handle services
    pp_deb_handle_services || exit $?

    # Create package dir 
    mkdir $pp_wrkdir/data

    # Make control files
    pp_deb_make_DEBIAN || exit $?

    # Copy in data
    pp_deb_make_data || exit $?

    # Create md5sums
    pp_deb_make_md5sums $pp_wrkdir/data/DEBIAN/md5sums `(cd $pp_wrkdir/data; find . -type f -a -not -name DEBIAN | sed "s,^\./,,")` || exit $?

    # Create debian package 
    dpkg-deb --build $pp_wrkdir/data $outfile
}

#@ pp_backend_deb(): processes output files to generate a package files
pp_backend_deb () {
    typeset debname

    debname=`pp_backend_deb_names`
    pp_deb_makedeb $pp_wrkdir/$debname || exit $?
}

#@ pp_backend_deb_cleanup(): removes any files created outside $pp_wrkdir
pp_backend_deb_cleanup () {
    # rm -rf $pp_wrkdir
    :
}

#@ pp_backend_deb_names(): prints the paths to package files
#    each path should start with $name-$version
#    the package must be relative to the $pp_wrkdir directory
pp_backend_deb_names () {
    echo "${pp_deb_name:-$name}${_subname}-${pp_deb_version:-$version}-${pp_deb_release:-1}.${pp_deb_arch:-$arch}.deb"
}

#@ pp_backend_deb_install_script(): generate a helper install script
pp_backend_deb_install_script () {
    pp_error "unimplemented (install_script)"
}

#@ pp_backend_deb_function(): output a platform-dependent function
pp_backend_deb_function() {

    case "$1" in
        pp_mkgroup) 
            cat<<'.';;
            /usr/sbin/groupadd -r $1
.
        pp_mkuser) 
            cat<<'.';;
            /usr/sbin/useradd -s /bin/false -M -r $@ 
.
        pp_havelib) cat<<'.';;
            typeset dir
            for dir in `echo "/usr/lib:/lib${3+:$3}" | tr : ' '`; do
                test -r "$dir/lib$1.so{$2+.$2}" && return 0
            done
            return 1
.
        *)
            pp_error "unknown function request: $1";;
    esac
}

#@ pp_backend_deb_probe(): output local platform's short id
pp_backend_deb_probe() {
    typeset arch distro release

    arch=`pp_deb_detect_arch`

    # /etc/debian_version exists on Debian & Ubuntu, so it's no use
    # to us. Use lsb_release instead.
    if [ ! lsb_release > /dev/null ]; then
        echo unknown-$arch
        return 0
    fi

    case `lsb_release -is` in
        Debian)
            distro=deb
        ;;
        Ubuntu)
            distro=ubu
        ;;
        *)
            distro=unknown
        ;;
    esac

    release=`lsb_release -rs`

    # If release is not numeric, use the codename
    case $release in
        [0-9]*.[0-9]*)
            release=`echo $release | tr -d .`
	;;
	*)
	    release=`lsb_release -cs`
	;;
    esac

    echo $distro$release-$arch
}
