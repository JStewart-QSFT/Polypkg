# rpm backend
#  The packages generated by this backend are suitable for
#  both redhat and linux.
# http://www.novell.com/coolsolutions/feature/11256.html

pp_platforms="$pp_platforms rpm"

#@ pp_backend_rpm_detect(uname_s): return true if this platform uses RPM
#    -- specific test for debian
pp_backend_rpm_detect () {
    test x"$1" = x"Linux" -a ! -f /etc/debian_version
}

#@ pp_backend_rpm_init(): initialises rpm backend variables
pp_backend_rpm_init () {

    pp_rpm_version=
    pp_rpm_summary=
    pp_rpm_description=
    pp_rpm_group="Applications/Internet"
    pp_rpm_license=Unspecified
    pp_rpm_vendor="Quest Software, Inc."
    pp_rpm_packager=
    pp_rpm_provides=
    pp_rpm_requires=
    pp_rpm_release=
    pp_rpm_epoch=
    pp_rpm_dev_group="Development/Libraries"
    pp_rpm_dbg_group="Development/Tools"
    pp_rpm_doc_group="Documentation"
    pp_rpm_dev_description=
    pp_rpm_dbg_description=
    pp_rpm_doc_description=
    pp_rpm_dev_requires=
    pp_rpm_dbg_requires=
    pp_rpm_doc_requires=
    pp_rpm_dev_provides=
    pp_rpm_dbg_provides=
    pp_rpm_doc_provides=

    pp_rpm_dbg_pkgname=debug
    pp_rpm_dev_pkgname=devel
    pp_rpm_doc_pkgname=doc

    pp_rpm_defattr_uid=root
    pp_rpm_defattr_gid=root

    pp_rpm_detect_arch
    pp_rpm_detect_distro
}

#@ pp_rpm_detect_arch(): sets $pp_rpm_arch to current RPM architecture
pp_rpm_detect_arch () {
    pp_rpm_arch=auto

    #-- Find the default native architecture that RPM is configured to use
    cat <<-. >$pp_wrkdir/dummy.spec
	Name: dummy
	Version: 1
	Release: 1
	Summary: dummy
	Group: ${pp_rpm_group}
	License: ${pp_rpm_license}
	%description
	dummy
.
    $pp_opt_debug && cat $pp_wrkdir/dummy.spec
    pp_rpm_arch_local=`rpm -q --qf '%{arch}\n' --specfile $pp_wrkdir/dummy.spec`
    rm $pp_wrkdir/dummy.spec

    #-- Ask the kernel what machine architecture is in use
    case "`uname -m`" in
	i?86)	pp_rpm_arch_std=i386;;
	x86_64)	pp_rpm_arch_std=x86_64;;
	ppc)	pp_rpm_arch_std=ppc;;
	ppc64)	pp_rpm_arch_std=ppc64;;
	ia64)	pp_rpm_arch_std=ia64;;
	*)	pp_rpm_arch_std=unknown;;
    esac

    #-- Later on, when files are processed, we use 'file' to determine
    #   what platform ABIs are used. This is used when pp_rpm_arch == auto
    pp_rpm_arch_seen=
}

#@ pp_rpm_detect_distro(): sets $pp_rpm_distro to a short distro name or ''
pp_rpm_detect_distro () {
    pp_rpm_distro=
    if test -f /etc/whitebox-release; then
       pp_rpm_distro=`awk '
          /^White Box Enterprise Linux release/ { print "wbel" $6; exit; }
       ' /etc/whitebox-release`
    elif test -f /etc/fedora-release; then
       pp_rpm_distro=`awk '
          /^Fedora Core release/ { print "fc" $4; exit; }
       ' /etc/fedora-release`
    elif test -f /etc/redhat-release; then
       pp_rpm_distro=`awk '
          /^Red Hat Enterprise Linux/ { print "rhel" $7; exit; }
          /^CentOS release/           { print "centos" $3; exit; }
          /^Red Hat Linux release/    { print "rh" $5; exit; }
       ' /etc/redhat-release`
    elif test -f /etc/SuSE-release; then
       pp_rpm_distro=`awk '
          /^SuSE Linux [0-9]/ { print "suse" $3; exit; }
          /^SUSE LINUX [0-9]/ { print "suse" $3; exit; }
          /^openSUSE [0-9]/   { print "suse" $2; exit; }
          /^SuSE Linux Enterprise Server [0-9]/ { print "sles" $5; exit; }
          /^SUSE LINUX Enterprise Server [0-9]/ { print "sles" $5; exit; }
       ' /etc/SuSE-release`
    fi
    pp_rpm_distro=`echo $pp_rpm_distro | tr -d .`
    test -z "$pp_rpm_distro" &&
       pp_warn "unknown distro"
}

#@ pp_rpm_label(label [arg...]): writes "$label: $arg" for each non-empty arg
pp_rpm_label () {
    typeset label arg
    label="$1"; shift
    for arg
    do
        test -z "$arg" || echo "$label: $arg"
    done
}

#@ pp_rpm_writefiles() < %files: Write body of a %files section in RPM form
pp_rpm_writefiles () {
    typeset _l t m o g f p st fo
    while read t m o g f p st; do
        _l="$p"
	test $t = d && _l="%dir ${_l%/}/"
        if test x"$m" = x"-"; then
            case "$t" in
                d) m=755;;
                f) m=644;;
            esac
        fi
        test x"$o" = x"-" && o="${pp_rpm_defattr_uid:-root}"
        test x"$g" = x"-" && g="${pp_rpm_defattr_gid:-root}"
	_l="%attr($m,$o,$g) $_l"

	if test "$t" = "f" -a x"$pp_rpm_arch" = x"auto"; then
	    fo=`file "${pp_destdir}$p" 2>/dev/null`
	    pp_debug "file: $fo"
	    #NB: The following should match executables and shared objects,
	    #relocatable objects. It will not match .a files however.
	    case "$fo" in
		*": ELF 32-bit LSB "*", Intel 80386"*)
		    pp_add_to_list pp_rpm_arch_seen i386;;
		*": ELF 64-bit LSB "*", AMD x86-64"*)
		    pp_add_to_list pp_rpm_arch_seen x86_64;;
		*": ELF 32-bit MSB "*", PowerPC"*)
		    pp_add_to_list pp_rpm_arch_seen ppc;;
		*": ELF 64-bit LSB "*", IA-64"*)
		    pp_add_to_list pp_rpm_arch_seen ia64;;
	    esac
	fi

	case $f in *v*) _l="%config $_l";; esac
	echo "$_l"
    done
    echo
}

#@ pp_rpm_subname(component hyphen): translate cpt into a linux subpackage name
pp_rpm_subname () {
    case "$1" in
        run) : ;;
        dbg) echo "${2}${pp_rpm_dbg_pkgname}";;
        dev) echo "${2}${pp_rpm_dev_pkgname}";;
        doc) echo "${2}${pp_rpm_doc_pkgname}";;
        *)   pp_error "unknown component '$1'";
    esac
}

#@ pp_rpm_depend() < %depend: generate Requires rules
pp_rpm_depend () {
    while read _name _vers; do
        case "$_name" in ""| "#"*) continue ;; esac
        echo "Requires: $_name ${_vers:+>= $_vers}"
    done
}

#@ pp_backend_rpm(): generate RPMs for the package
#-- Reads output files from the frontend and generates multiple output
#   package files under $pp_wrkdir/
pp_backend_rpm () {
        typeset cmp specfile _summary _group _desc _pkg _subname svc

	specfile=$pp_wrkdir/$name.spec
        : > $specfile

        #-- force existence of a 'run' component
        pp_add_component run
        : >> $pp_wrkdir/%files.run

	if test -z "$pp_rpm_arch"; then
            pp_error "Unknown RPM architecture"
            return 1
        fi

	#-- Write the header components of the RPM spec file
	cat <<-. >>$specfile
		Name: ${pp_rpm_name:-$name}
		Version: ${pp_rpm_version:-$version}
		Release: ${pp_rpm_release:-1}
		Summary: ${pp_rpm_summary:-$summary}
		Group:   ${pp_rpm_group}
		License: ${pp_rpm_license}
.
	pp_rpm_label "Vendor"   "$pp_rpm_vendor"   >>$specfile
	pp_rpm_label "Packager" "$pp_rpm_packager" >>$specfile
	pp_rpm_label "Provides" "$pp_rpm_provides" >>$specfile
	
	test -n "$pp_rpm_serial" && pp_warn "pp_rpm_serial deprecated"
	if test -n "$pp_rpm_epoch"; then
	    #-- Epoch was introduced in RPM 2.5.6
	    case `rpmbuild --version 2>/dev/null` in
		1.*|2.[0-5].*|2.5.[0-5]) 
		    pp_rpm_label "Serial" $pp_rpm_epoch >>$specfile;;
		*)
		    pp_rpm_label "Epoch" $pp_rpm_epoch >>$specfile;;
	    esac
	fi

        if test -n "$pp_rpm_requires"; then
            pp_rpm_label "Requires" "$pp_rpm_requires" >>$specfile
        elif test -s $pp_wrkdir/%depend.run; then
            pp_rpm_depend < $pp_wrkdir/%depend.run >> $specfile
        fi

	cat <<-. >>$specfile

		%description
		${pp_rpm_description:-$description}
.

	for cmp in $pp_components; do
		case $cmp in
		   run) continue;;
		   dev) _summary="development tools for $pp_rpm_summary"
		   	_group="$pp_rpm_dev_group"
			_desc="${pp_rpm_dev_description:-Development libraries for $name. $pp_rpm_description.}"
		   	;;
		   doc) _summary="documentation for $pp_rpm_summary"
		   	_group="$pp_rpm_doc_group"
			_desc="${pp_rpm_doc_description:-Documentation for $name. $pp_rpm_description.}"
		   	;;
		   dbg) _summary="diagnostic tools for $pp_rpm_summary"
		   	_group="$pp_rpm_dbg_group"
			_desc="${pp_rpm_dbg_description:-Diagnostic tools for $name.}"
		   	;;
		esac

                _subname=`pp_rpm_subname $cmp`
		cat <<-.

			%package $_subname
			Summary: $name $_summary
			Group: $_group
.
                eval '_pkg="$pp_rpm_'$cmp'_requires"'
                if test -n "$_pkg"; then
                    eval pp_rpm_label Requires ${pp_rpm_name:-$name} $_pkg
                elif test -s $pp_wrkdir/%depend.$cmp; then
                    pp_rpm_depend < $pp_wrkdir/%depend.$cmp >> $specfile
                fi

                eval '_pkg="$pp_rpm_'$cmp'_provides"'
		eval pp_rpm_label Provides $_pkg

		cat <<-.

			%description $_subname
			$_desc
.
	done >>$specfile

        #-- NB: we don't put any %prep, %build or %install RPM sections 
	#   into the spec file.

        #-- add service start/stop code
        if test -n "$pp_services"; then
            pp_rpm_service_install_common >> $pp_wrkdir/%post.run

            #-- record the uninstall commands in reverse order
            for svc in $pp_services; do
                pp_load_service_vars $svc

                pp_rpm_service_make_init_script $svc

                #-- append %post code to install the svc
                pp_rpm_service_install $svc >> $pp_wrkdir/%post.run

                #-- prepend %preun code to uninstall svc
                # (use files in case vars are modified)
                pp_rpm_service_remove $svc | pp_prepend $pp_wrkdir/%preun.run 
            done
            pp_rpm_service_remove_common | pp_prepend $pp_wrkdir/%preun.run
        fi

	# make convenience service groups
        if test -n "$pp_service_groups"; then
	    for grp in $pp_service_groups; do
		pp_rpm_service_group_make_init_script \
		    $grp "`pp_service_get_svc_group $grp`"
	    done
	fi

	#-- Write the RPM %file sections
        #   (do this after services, since services adds to %files.run)
	for cmp in $pp_components; do
            _subname=`pp_rpm_subname $cmp`

            if test -s $pp_wrkdir/%check.$cmp; then
                echo ""
                echo "%pre $_subname"
                cat $pp_wrkdir/%check.$cmp
                echo :   # causes script to exit true by default
            fi

            if test -s $pp_wrkdir/%files.$cmp; then
                echo ""
                echo "%files $_subname"
                pp_rpm_writefiles < $pp_wrkdir/%files.$cmp
            fi

            if test -s $pp_wrkdir/%post.$cmp; then
                echo ""
                echo "%post $_subname"
#               echo 'if test "$1" -eq 1; then # first install'
                cat $pp_wrkdir/%post.$cmp
                echo :   # causes script to exit true
#               echo 'fi'
            fi

            if test -s $pp_wrkdir/%preun.$cmp; then
                echo ""
                echo "%preun $_subname"
#               echo 'if test "$1" -eq 0; then # uninstall'
                cat $pp_wrkdir/%preun.$cmp
                echo :   # causes script to exit true
#               echo 'fi'
            fi
	done >>$specfile

        #-- create a suitable work area for rpmbuild
        echo "%_topdir $pp_wrkdir" >$pp_wrkdir/.rpmmacros
	mkdir $pp_wrkdir/RPMS
	mkdir $pp_wrkdir/BUILD

	if test x"$pp_rpm_arch" = x"auto"; then
	    #-- Reduce the arch_seen list to exactly one item
	    case "$pp_rpm_arch_seen" in
		"i386 x86_64"|"x86_64 i386")
		    pp_rpm_arch_seen=x86_64;;
		*" "*)
		    pp_warn "detected multiple targets: $pp_rpm_arch_seen"
		    pp_rpm_arch_seen=unknown;;	    # not detected
		"")
		    pp_warn "detected no binaries: using target noarch"
		    pp_rpm_arch_seen=noarch;;
		*)
		    pp_debug "detected architecture $pp_rpm_arch_seen"
	    esac
	    pp_rpm_arch="$pp_rpm_arch_seen"
	fi

        . $pp_wrkdir/%fixup

$pp_opt_debug && cat $specfile 

        pp_debug "creating: `pp_backend_rpm_names`"

pp_debug "pp_rpm_arch_seen = <${pp_rpm_arch_seen}>"
pp_debug "pp_rpm_arch = <${pp_rpm_arch}>"

	HOME=$pp_wrkdir \
	pp_verbose \
        rpmbuild -bb \
		--buildroot="$pp_destdir/" \
                --target="${pp_rpm_arch}" \
                --define='_unpackaged_files_terminate_build 0' \
                `$pp_opt_debug && echo --verbose || echo --quiet` \
                $pp_rpm_rpmbuild_extra_flags \
		$specfile || 
            pp_error "Problem creating RPM packages"

	for f in `pp_backend_rpm_names`; do
	    ln $pp_wrkdir/RPMS/${pp_rpm_arch}/$f $pp_wrkdir/$f ||
                pp_error "Problem predicting RPM filenames: $f"
	done
}

#@ pp_rpm_output_name($cpt): print the package names for the subpackage
pp_rpm_output_name () {
    echo "${pp_rpm_name:-$name}`pp_rpm_subname "$1" -`-${pp_rpm_version:-$version}-${pp_rpm_release:-1}.${pp_rpm_arch}.rpm"
}

#@ pp_backend_rpm_names(): print the package names generated
#   the names always start with $name-$version
pp_backend_rpm_names () {
    typeset cmp _subname
    for cmp in $pp_components; do
	pp_rpm_output_name $cmp
    done
}

pp_backend_rpm_cleanup () {
    :
}

#@ pp_rpm_print_requires(): prints the required features of the package
pp_rpm_print_requires () {
    typeset _subname _name

    echo "CPU:$pp_rpm_arch"
    ## XXX should be lines of the form (from file/ldd/objdump)
    #    EXEC:/bin/sh
    #    RTLD:libc.so.4:open
    rpm -q --requires -p $pp_wrkdir/`pp_rpm_output_name $1` |sed -e '/^rpmlib(/d;s/ //g;s/^/RPM:/' | sort -u
}

#@ pp_backend_rpm_install_script(): generate the install script
pp_backend_rpm_install_script () {
    typeset cmp _subname

    echo "#!/bin/sh"
    pp_install_script_common

    cat <<.

        cmp_to_pkgname () {
	    typeset oi name
	    if test x"\$1" = x"--only-installed"; then
		#-- only print if installation detected
		oi=false
		shift
	    else
		oi=true
	    fi
            test x"\$*" = x"all" && 
                set -- $pp_components
            for cmp
            do
                case \$cmp in
.
    for cmp in $pp_components; do
        _subname=`pp_rpm_subname $cmp -`
         echo "$cmp) name=${pp_rpm_name:-$name}${_subname};;"
    done
    cat <<.
                *) usage;;
                esac
		if \$oi || rpm -q "\$name" >/dev/null 2>/dev/null; then
		    echo "\$name"
		fi
            done
        }


        cmp_to_pathname () {
            test x"\$*" = x"all" && 
                set -- $pp_components
            for cmp
            do
                case \$cmp in
.
    for cmp in $pp_components; do
        echo "$cmp) echo \${PP_PKGDESTDIR:-.}/`pp_rpm_output_name $cmp` ;;"
    done
    cat <<.
                *) usage;;
                esac
            done
        }
	
	print_requires () {
            test x"\$*" = x"all" && 
                set -- $pp_components
            for cmp
            do
                case \$cmp in
.
    for cmp in $pp_components; do
        echo "$cmp) cat <<'._end'"
	pp_rpm_print_requires $cmp
        echo "._end"; echo ';;'
    done
    cat <<.
                *) usage;;
                esac
            done
        }

        test \$# -eq 0 && usage
        op="\$1"; shift
        case "\$op" in
            list-components) 
                test \$# -eq 0 || usage \$op
                echo $pp_components
                ;;
            list-services)
                test \$# -eq 0 || usage \$op
                echo $pp_services
                ;;
            list-files)
                test \$# -ge 1 || usage \$op
                cmp_to_pathname "\$@"
                ;;
            install)
                test \$# -ge 1 || usage \$op
                verbose rpm -U --replacepkgs --oldpackage \
                    \`cmp_to_pathname "\$@"\`
                ;;
            uninstall)
                test \$# -ge 1 || usage \$op
                pkgs=\`cmp_to_pkgname --only-installed "\$@"\`
                if test -z "\$pkgs"; then
                    verbosemsg "nothing to uninstall"
                else
                    verbose rpm -e \$pkgs
                fi
                ;;
            start|stop)
                test \$# -ge 1 || usage \$op
                ec=0
                for svc
                do
                    verbose /etc/init.d/\$svc \$op || ec=1
                done
                exit \$ec
                ;;
            print-platform)
                test \$# -eq 0 || usage \$op
		echo "linux-${pp_rpm_arch}"
		;;
            print-requires)
                test \$# -ge 1 || usage \$op
                print_requires "\$@"
		;;
            *)
                usage
                ;;
        esac
.

}

#@ pp_backend_rpm_function(func): emit shell code for a utility function
pp_backend_rpm_function () {
    case "$1" in
        pp_mkgroup) cat<<'.';;
            /usr/sbin/groupadd -r $1
.
        pp_mkuser) cat<<'.';;
            /usr/sbin/useradd -s /bin/false -M -r $@ 
.
        pp_havelib) cat<<'.';;
            typeset dir
            for dir in `echo "/usr/lib:/lib${3+:$3}" | tr : ' '`; do
                test -r "$dir/lib$1.so{$2+.$2}" && return 0
            done
            return 1
.
        *) pp_error "unknown function request: $1" ;;
    esac
}

#@ pp_backend_rpm_probe(): print the local platform's short name
pp_backend_rpm_probe () {
        echo "${pp_rpm_distro}-${pp_rpm_arch_std}"
}

#@ pp_backend_rpm_vas_platforms(): print the VAS platform identifiers
pp_backend_rpm_vas_platforms () {
    case "$pp_rpm_arch_std" in
	x86_64)	echo "linux-x86_64.rpm linux-x86.rpm";;
	*86)	echo "linux-x86.rpm";;
	s390)	echo "linux-s390";;
	s390x)	echo "linux-s390x";;
	ppc*)	echo "linux-glibc23-ppc64 linux-glibc22-ppc64";;
	ia64)	echo "linux-ia64";;
	*)	pp_die "unknown architecture $pp_rpm_arch_std";;
    esac
}
