# rpm backend
#  The packages generated by this backend are suitable for
#  both redhat and linux.
# http://www.novell.com/coolsolutions/feature/11256.html

pp_platforms="$pp_platforms rpm"

#@ pp_backend_rpm_detect(uname_s): return true if this platform uses RPM
pp_backend_rpm_detect () {
    test x"$1" = x"Linux"
}

#@ pp_backend_rpm_init(): initialises rpm backend variables
pp_backend_rpm_init () {

    pp_rpm_version=
    pp_rpm_summary=
    pp_rpm_description=
    pp_rpm_group="Applications/Internet"
    pp_rpm_license=Unspecified
    pp_rpm_vendor="Quest Software, Inc."
    pp_rpm_packager=
    pp_rpm_provides=
    pp_rpm_requires=
    pp_rpm_dev_group="Development/Libraries"
    pp_rpm_dbg_group="Development/Tools"
    pp_rpm_doc_group="Documentation"
    pp_rpm_dev_description=
    pp_rpm_dbg_description=
    pp_rpm_doc_description=
    pp_rpm_dev_requires=
    pp_rpm_dbg_requires=
    pp_rpm_doc_requires=
    pp_rpm_dev_provides=
    pp_rpm_dbg_provides=
    pp_rpm_doc_provides=

    pp_rpm_detect_arch

    #-- initialise service-specific variables
    pp_backend_rpm_init_svc
}

#@ pp_rpm_detect_arch(): sets $pp_rpm_arch to current RPM architecture
pp_rpm_detect_arch () {
    #-- Build a dummy spec file so we can query properties with rpm -q
    cat <<-"." >$pp_wrkdir/dummy.spec
	Name: dummy
	Version: 1
	Release: 1
	Summary: dummy
	Group: ${pp_rpm_group}
	License: ${pp_rpm_license}
	%description
	dummy
.
    cat $pp_wrkdir/dummy.spec
    pp_rpm_arch=`rpm -q --qf '%{arch}\n' --specfile $pp_wrkdir/dummy.spec`
    rm $pp_wrkdir/dummy.spec
}

#@ pp_rpm_label(label [arg...]): writes "$label: $arg" for each non-empty arg
pp_rpm_label () {
    typeset label arg
    label="$1"; shift
    for arg
    do
        test -z "$arg" || echo "$label: $arg"
    done
}

#@ pp_rpm_writefiles() < %files: Write body of a %files section in RPM form
pp_rpm_writefiles () {
    while read t m o g f p st; do
        line="$p"
	test $t = d && line = "%dir $line/"
        if test x"$m" = x"-"; then
            case "$t" in
                d) m=755;;
                f) m=644;;
            esac
        fi
	line="%attr($m,$o,$g) $line"
	case $f in *v*) line="%config $line";; esac
	echo "$line"
    done
    echo
}

#@ pp_rpm_subname(component hyphen): translate cpt into a linux subpackage name
pp_rpm_subname () {
    case "$1" in
        run) : ;;
        dbg) echo "${2}debug";;
        dev) echo "${2}devel";;
        doc) echo "${2}doc";;
        *)   pp_error "unknown component '$1'";
    esac
}

#@ pp_rpm_cleanup_later(file): schedule future removal of $pp_destdir/file
pp_rpm_cleanup_later () {
    #-- insert the file at the beginning of the cleanup list
    {
      echo "$1"; 
      test -s $pp_wrkdir/cleanup && cat $pp_wrkdir/cleanup; 
    } > $pp_wrkdir/cleanup.NEW
    mv $pp_wrkdir/cleanup.NEW $pp_wrkdir/cleanup
}

#@ pp_backend_rpm_cleanup(): removes any leftover files
pp_backend_rpm_cleanup () {
    typeset f
    if test -s $pp_wrkdir/cleanup; then
        while read f; do
            pp_debug "removing $pp_destdir$f"
            rm -rf "$pp_destdir$f"
        done < $pp_wrkdir/cleanup
    fi
}

#@ pp_backend_rpm(): generate RPMs for the package
#-- Reads output files from the frontend and generates multiple output
#   package files under $pp_wrkdir/
pp_backend_rpm () {
        typeset cmp specfile _summary _group _desc _pkg _subname svc

	specfile=$pp_wrkdir/$name.spec
        : > $specfile

        #-- force existence of a 'run' component
        pp_add_component run
        : >> $pp_wrkdir/%files.run

	if test -z "$pp_rpm_arch"; then
            pp_error "Unknown RPM architecture"
            return 1
        fi

	test -z "$pp_rpm_description" && 
            pp_rpm_description="This is the $name package"

	#-- Write the header components of the RPM spec file
	cat <<-. >>$specfile
		Name: ${pp_rpm_name:-$name}
		Version: ${pp_rpm_version:-$version}
		Release: 1
		Summary: ${pp_rpm_summary:-$summary}
		Group:   ${pp_rpm_group}
		License: ${pp_rpm_license}
.
	pp_rpm_label "Vendor"   "$pp_rpm_vendor"   >>$specfile
	pp_rpm_label "Packager" "$pp_rpm_packager" >>$specfile
	pp_rpm_label "Requires" "$pp_rpm_requires" >>$specfile
	pp_rpm_label "Provides" "$pp_rpm_provides" >>$specfile

	cat <<-. >>$specfile

		%description
		${pp_rpm_description:-$description}
.

	for cmp in $pp_components; do
		case $cmp in
		   run) continue;;
		   dev) _summary="development tools for $pp_rpm_summary"
		   	_group="$pp_rpm_dev_group"
			_desc="${pp_rpm_dev_description:-Development libraries for $name. $pp_rpm_description.}"
		   	;;
		   doc) _summary="documentation for $pp_rpm_summary"
		   	_group="$pp_rpm_doc_group"
			_desc="${pp_rpm_doc_description:-Documentation for $name. $pp_rpm_description.}"
		   	;;
		   dbg) _summary="diagnostic tools for $pp_rpm_summary"
		   	_group="$pp_rpm_dbg_group"
			_desc="${pp_rpm_dbg_description:-Diagnostic tools for $name.}"
		   	;;
		esac

                _subname=`pp_rpm_subname $cmp`
		cat <<-.

			%package $_subname
			Summary: $name $_summary
			Group: $_group
.
                eval '_pkg="$pp_rpm_'$cmp'_requires"'
		eval pp_rpm_label Requires ${pp_rpm_name:-$name} $_pkg

                eval '_pkg="$pp_rpm_'$cmp'_provides"'
		eval pp_rpm_label Provides $_pkg

		cat <<-.

		    %description $cmp
		    $_desc
.
	done >>$specfile

        #-- NB: we don't write ant %prep, %build or %install RPM sections 

        #-- add service start/stop code
        if test -n "$pp_services"; then
            pp_rpm_service_install_common >> $pp_wrkdir/%post.run
            pp_rpm_service_remove_common >> $pp_wrkdir/%preun.run

            #-- record the uninstall commands in reverse order
            preun=$pp_wrkdir/svc.preun
            : >$preun
            for svc in $pp_services; do
                pp_rpm_init_service_vars    # initialise RPM-specific vars
                pp_load_service_vars $svc

                pp_rpm_service_make_init_script $svc

                #-- append %post code to install the svc
                pp_rpm_service_install $svc >> $pp_wrkdir/%post.run

                #-- preprned %preun code to uninstall svc
                : >> $pp_wrkdir/%preun.run
                mv $preun $preun.OLD
                { pp_rpm_service_remove $svc; cat $preun.OLD; } >> $preun
                rm -f $preun.OLD
            done
            cat $preun >> $pp_wrkdir/%preun.run
        fi

	#-- Write the RPM %file sections
        #   (do this after services, since services adds to %files.run)
	for cmp in $pp_components; do
            _subname=`pp_rpm_subname $cmp`

            if test -s $pp_wrkdir/%files.$cmp; then
                echo ""
                echo "%files $_subname"
                echo "%defattr(-,root,root)"
                pp_rpm_writefiles < $pp_wrkdir/%files.$cmp
            fi

            if test -s $pp_wrkdir/%post.$cmp; then
                echo ""
                echo "%post $_subname"
                echo 'if test "$1" -eq 1; then # first install'
                cat $pp_wrkdir/%post.$cmp
                echo 'fi'
            fi

            if test -s $pp_wrkdir/%preun.$cmp; then
                echo ""
                echo "%preun $_subname"
                echo 'if test "$1" -eq 0; then # uninstall'
                cat $pp_wrkdir/%preun.$cmp
                echo 'fi'
            fi
	done >>$specfile

$pp_opt_debug && cat $specfile 

        #-- create a suitable work area for rpmbuild
        echo "%_topdir $pp_wrkdir" >$pp_wrkdir/.rpmmacros
	mkdir $pp_wrkdir/RPMS
	mkdir $pp_wrkdir/BUILD

        . $pp_wrkdir/%fixup

        pp_debug "creating: `pp_backend_rpm_names`"

	HOME=$pp_wrkdir \
        rpmbuild -v -bb \
		--buildroot "$pp_destdir/" \
                --target=${pp_rpm_arch} \
		$specfile || 
            pp_error "Problem creating RPM packages"

	for f in `pp_backend_rpm_names`; do
	    ln $pp_wrkdir/RPMS/${pp_rpm_arch}/$f $pp_wrkdir/$f ||
                pp_error "Problem predicting RPM filenames: $f"
	done
}

#@ pp_backend_rpm_names(): print the package names generated
#   the names always start with $name-$version
pp_backend_rpm_names () {
    typeset cmp _subname
    for cmp in $pp_components; do
        _subname=`pp_rpm_subname $cmp -`
        echo "${pp_rpm_name:-$name}${_subname}-${pp_rpm_version:-$version}-${pp_rpm_revision:-1}.${pp_rpm_arch}.rpm"
    done
}

#-- (re-)installs the newly created package
pp_backend_rpm_install () {
	:
}
