# rpm backend
#  The packages generated by this backend are suitable for
#  both redhat and linux.
# http://www.novell.com/coolsolutions/feature/11256.html

pp_platforms="$pp_platforms rpm"

#@ pp_backend_rpm_detect(uname_s): return true if this platform uses RPM
pp_backend_rpm_detect () {
    test x"$1" = x"Linux"
}

#@ pp_backend_rpm_init(): initialises rpm backend variables
pp_backend_rpm_init () {

    pp_rpm_version=
    pp_rpm_summary=
    pp_rpm_description=
    pp_rpm_group="Applications/Internet"
    pp_rpm_license=Unspecified
    pp_rpm_vendor="Quest Software, Inc."
    pp_rpm_packager=
    pp_rpm_provides=
    pp_rpm_requires=
    pp_rpm_dev_group="Development/Libraries"
    pp_rpm_dbg_group="Development/Tools"
    pp_rpm_doc_group="Documentation"
    pp_rpm_dev_description=
    pp_rpm_dbg_description=
    pp_rpm_doc_description=
    pp_rpm_dev_requires=
    pp_rpm_dbg_requires=
    pp_rpm_doc_requires=
    pp_rpm_dev_provides=
    pp_rpm_dbg_provides=
    pp_rpm_doc_provides=

    pp_rpm_dbg_pkgname=debug
    pp_rpm_dev_pkgname=devel
    pp_rpm_doc_pkgname=doc

    pp_rpm_detect_arch
}

#@ pp_rpm_detect_arch(): sets $pp_rpm_arch to current RPM architecture
pp_rpm_detect_arch () {
    #-- Build a dummy spec file so we can query properties with rpm -q
    cat <<-. >$pp_wrkdir/dummy.spec
	Name: dummy
	Version: 1
	Release: 1
	Summary: dummy
	Group: ${pp_rpm_group}
	License: ${pp_rpm_license}
	%description
	dummy
.
    $pp_opt_debug && cat $pp_wrkdir/dummy.spec
    pp_rpm_arch=`rpm -q --qf '%{arch}\n' --specfile $pp_wrkdir/dummy.spec`
    rm $pp_wrkdir/dummy.spec
}

#@ pp_rpm_label(label [arg...]): writes "$label: $arg" for each non-empty arg
pp_rpm_label () {
    typeset label arg
    label="$1"; shift
    for arg
    do
        test -z "$arg" || echo "$label: $arg"
    done
}

#@ pp_rpm_writefiles() < %files: Write body of a %files section in RPM form
pp_rpm_writefiles () {
    typeset _l t m o g f p st
    while read t m o g f p st; do
        _l="$p"
	test $t = d && _l="%dir ${_l%/}/"
        if test x"$m" = x"-"; then
            case "$t" in
                d) m=755;;
                f) m=644;;
            esac
        fi
	_l="%attr($m,$o,$g) $_l"
	case $f in *v*) _l="%config $_l";; esac
	echo "$_l"
    done
    echo
}

#@ pp_rpm_subname(component hyphen): translate cpt into a linux subpackage name
pp_rpm_subname () {
    case "$1" in
        run) : ;;
        dbg) echo "${2}${pp_rpm_dbg_pkgname}";;
        dev) echo "${2}${pp_rpm_dev_pkgname}";;
        doc) echo "${2}${pp_rpm_doc_pkgname}";;
        *)   pp_error "unknown component '$1'";
    esac
}

#@ pp_rpm_depend() < %depend: generate Requires rules
pp_rpm_depend () {
    while read _name _vers; do
        case "$_name" in ""| "#"*) continue ;; esac
        echo "Requires: $_name ${_vers:+>= $_vers}"
    done
}

#@ pp_backend_rpm(): generate RPMs for the package
#-- Reads output files from the frontend and generates multiple output
#   package files under $pp_wrkdir/
pp_backend_rpm () {
        typeset cmp specfile _summary _group _desc _pkg _subname svc

	specfile=$pp_wrkdir/$name.spec
        : > $specfile

        #-- force existence of a 'run' component
        pp_add_component run
        : >> $pp_wrkdir/%files.run

	if test -z "$pp_rpm_arch"; then
            pp_error "Unknown RPM architecture"
            return 1
        fi

	test -z "$pp_rpm_description" && 
            pp_rpm_description="This is the $name package"

	#-- Write the header components of the RPM spec file
	cat <<-. >>$specfile
		Name: ${pp_rpm_name:-$name}
		Version: ${pp_rpm_version:-$version}
		Release: 1
		Summary: ${pp_rpm_summary:-$summary}
		Group:   ${pp_rpm_group}
		License: ${pp_rpm_license}
.
	pp_rpm_label "Vendor"   "$pp_rpm_vendor"   >>$specfile
	pp_rpm_label "Packager" "$pp_rpm_packager" >>$specfile
	pp_rpm_label "Provides" "$pp_rpm_provides" >>$specfile

        if test -n "$pp_rpm_requires"; then
            pp_rpm_label "Requires" "$pp_rpm_requires" >>$specfile
        elif test -s $pp_wrkdir/%depend.run; then
            pp_rpm_depend < $pp_wrkdir/%depend.run >> $specfile
        fi

	cat <<-. >>$specfile

		%description
		${pp_rpm_description:-$description}
.

	for cmp in $pp_components; do
		case $cmp in
		   run) continue;;
		   dev) _summary="development tools for $pp_rpm_summary"
		   	_group="$pp_rpm_dev_group"
			_desc="${pp_rpm_dev_description:-Development libraries for $name. $pp_rpm_description.}"
		   	;;
		   doc) _summary="documentation for $pp_rpm_summary"
		   	_group="$pp_rpm_doc_group"
			_desc="${pp_rpm_doc_description:-Documentation for $name. $pp_rpm_description.}"
		   	;;
		   dbg) _summary="diagnostic tools for $pp_rpm_summary"
		   	_group="$pp_rpm_dbg_group"
			_desc="${pp_rpm_dbg_description:-Diagnostic tools for $name.}"
		   	;;
		esac

                _subname=`pp_rpm_subname $cmp`
		cat <<-.

			%package $_subname
			Summary: $name $_summary
			Group: $_group
.
                eval '_pkg="$pp_rpm_'$cmp'_requires"'
                if test -n "$_pkg"; then
                    eval pp_rpm_label Requires ${pp_rpm_name:-$name} $_pkg
                elif test -s $pp_wrkdir/%depend.$cmp; then
                    pp_rpm_depend < $pp_wrkdir/%depend.$cmp >> $specfile
                fi

                eval '_pkg="$pp_rpm_'$cmp'_provides"'
		eval pp_rpm_label Provides $_pkg

		cat <<-.

			%description $_subname
			$_desc
.
	done >>$specfile

        #-- NB: we don't write ant %prep, %build or %install RPM sections 

        #-- add service start/stop code
        if test -n "$pp_services"; then
            pp_rpm_service_install_common >> $pp_wrkdir/%post.run

            #-- record the uninstall commands in reverse order
            for svc in $pp_services; do
                pp_load_service_vars $svc

                pp_rpm_service_make_init_script $svc

                #-- append %post code to install the svc
                pp_rpm_service_install $svc >> $pp_wrkdir/%post.run

                #-- prepend %preun code to uninstall svc
                # (use files in case vars are modified)
                pp_rpm_service_remove $svc | pp_prepend $pp_wrkdir/%preun.run 
            done
            pp_rpm_service_remove_common | pp_prepend $pp_wrkdir/%preun.run
        fi

	#-- Write the RPM %file sections
        #   (do this after services, since services adds to %files.run)
	for cmp in $pp_components; do
            _subname=`pp_rpm_subname $cmp`

            if test -s $pp_wrkdir/%files.$cmp; then
                echo ""
                echo "%files $_subname"
                echo "%defattr(-,root,root)"
                pp_rpm_writefiles < $pp_wrkdir/%files.$cmp
            fi

            if test -s $pp_wrkdir/%post.$cmp; then
                echo ""
                echo "%post $_subname"
                echo 'if test "$1" -eq 1; then # first install'
                cat $pp_wrkdir/%post.$cmp
                echo 'fi'
            fi

            if test -s $pp_wrkdir/%preun.$cmp; then
                echo ""
                echo "%preun $_subname"
                echo 'if test "$1" -eq 0; then # uninstall'
                cat $pp_wrkdir/%preun.$cmp
                echo 'fi'
            fi
	done >>$specfile

$pp_opt_debug && cat $specfile 

        #-- create a suitable work area for rpmbuild
        echo "%_topdir $pp_wrkdir" >$pp_wrkdir/.rpmmacros
	mkdir $pp_wrkdir/RPMS
	mkdir $pp_wrkdir/BUILD

        . $pp_wrkdir/%fixup

        pp_debug "creating: `pp_backend_rpm_names`"

	HOME=$pp_wrkdir \
        rpmbuild -bb \
		--buildroot="$pp_destdir/" \
                --target="${pp_rpm_arch}" \
                --define='_unpackaged_files_terminate_build 0' \
                `$pp_opt_debug && echo --verbose || echo --quiet` \
                $pp_rpm_rpmbuild_extra_flags \
		$specfile || 
            pp_error "Problem creating RPM packages"

	for f in `pp_backend_rpm_names`; do
	    ln $pp_wrkdir/RPMS/${pp_rpm_arch}/$f $pp_wrkdir/$f ||
                pp_error "Problem predicting RPM filenames: $f"
	done
}

#@ pp_backend_rpm_names(): print the package names generated
#   the names always start with $name-$version
pp_backend_rpm_names () {
    typeset cmp _subname
    for cmp in $pp_components; do
        _subname=`pp_rpm_subname $cmp -`
        echo "${pp_rpm_name:-$name}${_subname}-${pp_rpm_version:-$version}-${pp_rpm_revision:-1}.${pp_rpm_arch}.rpm"
    done
}

pp_backend_rpm_cleanup () {
    :
}

pp_backend_rpm_install () {
	:
}
