# http://www.sun.com/bigadmin/content/selfheal/sdev_intro.html
# http://opensolaris.org/os/community/smf/faq

#@ pp_backend_solaris_init_svc_vars(): initialise service var defaults
pp_backend_solaris_init_svc_vars () {
    pp_solaris_smf_category=
    pp_solaris_service_shell=/sbin/sh
}

#@ pp_solaris_init_svc(): initialise solaris backend vars for services
pp_solaris_init_svc () {
    smf_category=${pp_solaris_smf_category:-application}
    smf_version=1
    smf_type=service
    solaris_user=
    solaris_stop_signal=
    solaris_sysv_init_start=S98     # invocation order for start scripts
    solaris_sysv_init_kill=K30      # invocation order for kill scripts
    solaris_sysv_init_start_states="2" # states to install start link
    solaris_sysv_init_kill_states="S 0 1"  # states to install kill link

    #
    # To have the service be installed to start automatically,
    #   %service foo
    #   solaris_sysv_init_start_states="S 0 1 2"
    #
}

#@ pp_solaris_smf(svc): create an service file
#  -- FIXME: incomplete
pp_solaris_smf () {
    typeset f
    f=/var/svc/manifest/$smf_category/$1
    pp_add_file_if_missing $f ||
        return 0

    cat <<-. >$pp_destdir$f
	<?xml version="1.0"?>
        <!-- 
            $copyright 
            Generated by PolyPackage $pp_version
	-->

        <service name='$smf_category/$1'
                 type='$smf_type'
                 version='$smf_version'>

            <single_instance />

            <exec_method type='method' name='start'
                exec='' 
                timeout_seconds='60'>
                <method_context>
                  <method_credential user='${solaris_user:-$user}' />
                </method_context>
            </exec>

            <exec_method type='method' name='stop'
                exec=':kill -${solaris_stop_signal:-$stop_signal}'>
                <method_context>
                  <method_credential user='${solaris_user:-$user}' />
                </method_context>
            </exec>

        </service>
.
}

#@ pp_solaris_make_service_group (group svcs): create a SysV service group 
#  script and adds it to %files.run if not there already
pp_solaris_make_service_group () {
    typeset group out file svcs svc

    group="$1"
    svcs="$2"
    file="/etc/init.d/$group"
    out="$pp_destdir$file"

    #-- return if the script is supplued already
    pp_add_file_if_missing "$file" run 755 || return 0

    echo "#! /sbin/sh" > $out
    echo "# polypkg service group script for these services:" >> $out
    echo "svcs=\"$svcs\"" >> $out

    cat <<'.' >>$out

	#-- starts services in order.. stops them all if any break
	pp_start () {
	    undo=
	    for svc in $svcs; do
		if /etc/init.d/$svc start; then
		    undo="$svc $undo"
		else
		    if test -n "$undo"; then
		        for svc in $undo; do
			   /etc/init.d/$svc stop
			done
			return 1
		    fi
		fi
	    done
	    return 0
	}

	#-- stops services in reverse
	pp_stop () {
	    reverse=
	    for svc in $svcs; do
		reverse="$svc $reverse"
	    done
	    rc=0
	    for svc in $reverse; do
		/etc/init.d/$svc stop || rc=$?
	    done
	    return $rc
	}

	#-- returns true only if all services return true status
	pp_status () {
	    rc=0
	    for svc in $svcs; do
		/etc/init.d/$svc status || rc=$?
	    done
	    return $rc
	}

        case "$1" in
            start)   pp_start;;
            stop)    pp_stop;;
            status)  pp_status;;
            restart) pp_stop && pp_start;;
            *)       echo "usage: $0 {start|stop|restart|status}" >&2; exit 1;;
        esac
.
}


#@ pp_solaris_make_service (svc): create a SysV service script
#   creates and adds the file /etc/init.d/$svc to %files.run if
#   it isn't there already.
pp_solaris_make_service () {
    typeset file out _cmd svc

    svc="$1"
    file="/etc/init.d/$svc"
    out="$pp_destdir$file"


    #-- return if we don't need to create the init script
    pp_add_file_if_missing "$file" run 755 ||
        return 0

    echo "#! /sbin/sh" >$out
    echo "#-- This service init file generated by polypkg" >>$out

    #-- construct a start command that builds a pid file as needed
    #   and forks the daemon
    _cmd="$cmd";
    if test -z "$pidfile"; then
	# We wrap the start command with something to write the PID file
	cat <<. >>$out
	    # Figure out the piddir
	    if test -z "$piddir"; then
		pp_piddir="/var/run"
		test -d $pp_piddir || pp_piddir="/tmp"
		pidfile="$pp_piddir/$svc.pid"
	    else
		pidfile="$piddir/$svc.pid"
	    fi
.
        _cmd="$cmd & echo \$! > \$pidfile"
    else
	# The service is able to write its own PID file
	cat <<. >>$out
	    pidfile="$pidfile"
.
    fi

    if test "${user:-root}" != "root"; then
        _cmd="su $user -c exec $_cmd";
    fi

    cat <<. >>$out
	stop_signal="${stop_signal:-TERM}"
	svc="${svc}"

        # generated command to run $svc as a daemon process
        pp_exec () { $_cmd; }
.

    #-- write the invariant section of the init script
    cat <<'.' >>$out

        # returns true if $svc is running
        pp_running () {
            test -r "$pidfile" &&
            read pid junk < "$pidfile" &&
            test ${pid:-0} -gt 1 &&
            kill -0 "$pid" 2>/dev/null
        }

        # prints a message describing $svc's running state
        pp_status () {
            if pp_running; then
                echo "service $svc is running (pid $pid)"
                return 0
            elif test -f "$pidfile"; then
                echo "service $svc is not running, but pid file exists" 
                return 2
            else
                echo "service $svc is not running" 
                return 1
            fi
        }

        # starts $svc
        pp_start () {
            if pp_running; then
                echo "service $svc already running" >&2
                return 0
            fi
            echo "starting $svc... \c"
            if pp_exec; then
                echo "done."
            else
                echo "ERROR."
                exit 1
            fi
        }

        # stops $svc
        pp_stop () {
            if pp_running; then
                echo "stopping $svc... \c"
                if kill -$stop_signal $pid; then
                    rm -f "$pidfile"
                    echo "done."
                else
                    echo "ERROR."
                    return 1
                fi
            else
                echo "service $svc already stopped" >&2
                return 0
            fi
        }

        umask 022
        case "$1" in
            start)   pp_start;;
            stop)    pp_stop;;
            status)  pp_status;;
            restart) pp_stop && pp_start;;
            *)       echo "usage: $0 {start|stop|restart|status}" >&2; exit 1;;
        esac
.
}


#@ pp_solaris_install_service($svc): generate commands to install svc
#   output is intended to go to postinstall
pp_solaris_install_service () {
    typeset s k l
    s="${solaris_sysv_init_start}$1"
    k="${solaris_sysv_init_kill}$1"

    echo 'case " $SERVICES " in *" '$1' "*)'
    test -n "${solaris_sysv_init_start_states}" &&
        for state in ${solaris_sysv_init_start_states}; do
            l="/etc/rc$state.d/$s"
            echo "echo '$l'"
            echo "installf -c run \$PKGINST \$PKG_INSTALL_ROOT$l=../init.d/$1 s"
            pp_solaris_space /etc/rc$state.d 0 1
        done
    test -n "${solaris_sysv_init_kill_states}" &&
        for state in ${solaris_sysv_init_kill_states}; do
            l="/etc/rc$state.d/$k"
            echo "echo '$l'"
            echo "installf -c run \$PKGINST \$PKG_INSTALL_ROOT$l=../init.d/$1 s"
            pp_solaris_space /etc/rc$state.d 0 1
        done
    echo " :;; esac"

}
