
#@ $pp_shlib_suffix: used to replace .%so at end of %files paths
#    -- platform initialisation functions may (should) change this
pp_shlib_suffix='.so*'

#@ pp_have_component(component): return true if component was defined
pp_have_component () {
	pp_contains "$pp_components" "$1"
}

#@ pp_have_all_components(component...): return true if all components defined
pp_have_all_components () {
	pp_contains_all "$pp_components" ${1+"$@"}
}

#@ pp_add_component(component): adds component to $pp_components
pp_add_component () {
	pp_add_to_list 'pp_components' "$1"
}

#@ pp_add_service(service): adds service to $pp_services
pp_add_service () {
	pp_add_to_list 'pp_services' "$1"
}

#@ pp_service_init_vars(): initialises user service variables
pp_service_init_vars () {
	cmd=
	pidfile=
	stop_signal=15		# SIGTERM
	user=root
}

#@ pp_service_check_vars(service): error if required user variables are unset
pp_service_check_vars () {
	test -n "$cmd" ||
		pp_error "%service $1: cmd not defined"
	
}

#@ pp_load_service_vars(svc): source a file for service definitions
pp_load_service_vars () {
	pp_service_init_vars
	. "$pp_wrkdir/%service.$1" 
	pp_service_check_vars "$1"
}

#@ pp_files_expand(path [m] [[u]:[g]] [f] [t]): expand to a file path
#    writes multiple lines of the form
#       type path mode owner group flags [target]
#    flags contains the letter v if the file is volatile
pp_files_expand () {
    typeset _p _mode _group _owner _flags _path _optional _has_target _tree
    typeset _path _file _tgt _m _o _g _f _type _lm _ll _lo _lg _ls _lx
    typeset _ignore

    test $# -eq 0 && return

    pp_debug "pp_files_expand: $*"

    case "$1" in "#"*) return;; esac
    _p="$1"; shift

    #-- the mode must be an octal number of at least three digits
    _mode="="
    case "$1" in
	*:*) :;;
	-|=|[01234567][01234567][01234567]*) _mode="$1"; shift;;
    esac

    #-- the owner:group field may have optional parts
    case "$1" in
	*:*) _group=${1#*:}; _owner=${1%:*}; shift;;
	=|-) _group=$1;      _owner=$1; shift;;
	*)   _group=-;       _owner=-;;
    esac

    #-- process the flags argument
    _flags=
    _optional=false
    _has_target=false
    _ignore=false
    if test $# -gt 0; then
	case ",$1," in *,volatile,*) _flags="${_flags}v";; esac
	case ",$1," in *,optional,*) _optional=true;; esac
	case ",$1," in *,symlink,*) _has_target=true;; esac
	case ",$1," in *,ignore-others,*) _flags="${_flags}i";; esac
	case ",$1," in *,ignore,*) _ignore=true;; esac
	shift
    fi

    #-- process the target argument
    if $_has_target; then
	test $# -ne 0 || pp_error "$_p: missing target"
	_target="$1"
	shift
    fi

    test $# -eq 0 || pp_error "$_p: too many arguments"

    #-- process speciall suffixes
    tree=
    case "$_p" in
        *"/**")  _p=${_p%"/**"}; tree="**";;
        *".%so") _p=${_p%".%so"}"$pp_shlib_suffix"
    esac

    #-- expand the path using the shell glob
    pp_debug "expanding .$_p ..."
    (cd ${pp_destdir} && $pp_expand_path ".$_p") > $pp_wrkdir/tmp.files.exp

    #-- expand path/** by rewriting the glob output file
    case "$tree" in
        "") : ;;
        "**")
            pp_debug "expanding /** tree ..."
            while read _path; do
                _path="${_path#.}"
                pp_find_recurse "$pp_destdir${_path%/}"
            done < $pp_wrkdir/tmp.files.exp | 
                 sort -u > $pp_wrkdir/tmp.files.exp2
            mv $pp_wrkdir/tmp.files.exp2 $pp_wrkdir/tmp.files.exp
            ;;
    esac

    while read _path; do
	_path="${_path#.}"
	_file="${pp_destdir}${_path}"
	_tgt=
	_m="$_mode"
	_o="$_owner" 
	_g="$_group"
	_f="$_flags"

        case "$_path" in 
            /*) :;; 
            *)  pp_warn "$_path: inserting leading /"
                _path="/$_path";;  # ensure leading /
        esac

        #-- sanity checks
        case "$_path" in
            */../*|*/..) pp_error "$_path: invalid .. in path";;
            */./*|*/.)   pp_warn  "$_path: invalid component . in path";;
            *//*)        pp_warn  "$_path: redundant / in path";;
        esac

	#-- set the type based on the real file's type
        if $_ignore; then
           _type=f _m=_ _o=_ _g=_
	elif test -h "$_file"; then
	   _type=s
	   if test x"$_target" != x"="; then
	       _tgt="$_target"
	   else
	       _tgt=`readlink "$_file"` || 
                    pp_error "can't readlink $_file"
               _tgt="${_tgt#$pp_destdir}"
               # FIXME.. should we correct the symlink in situ??
	   fi
	   _m=777
	elif test -d "$_file"; then
	   #-- display a warning if the user forgot the trailing /
	   case "$_path" in 
		*/) :;; 
		*) pp_warn "$_path (matching $_file): adding trailing /"
		   _path="$_path/";;
	   esac
	   _type=d
	   $_has_target && pp_error "$_file: not a symlink"
	elif test -f "$_file"; then
	   case "$_path" in
		*/) pp_warn "$_path (matching $_file): removing trailing /"
		    _path="${_path%/}"
		    ;;
	   esac
	   _type=f
	   $_has_target && pp_error "$_file: not a symlink"
	else
	   $_optional && continue
	   pp_error "$_file: missing"
	   _type=f
	fi

	#-- convert '=' shortcuts into mode/owner/group from ls
	case ":$_m:$_o:$_g:" in *:=:*)
	    if /bin/ls -l1d "$_file" > $pp_wrkdir/ls.tmp; then
                read _lm _ll _lo _lg _ls _lx < $pp_wrkdir/ls.tmp
                test x"$_m" = x"=" && _m=`pp_mode_from_ls "$_lm"`
                test x"$_o" = x"=" && _o="$_lo"
                test x"$_g" = x"=" && _g="$_lg"
            else
                pp_error "cannot read $_file"
                test x"$_m" = x"=" && _m=-
                test x"$_o" = x"=" && _o=-
                test x"$_g" = x"=" && _g=-
            fi
	    ;;
	esac
	
	test -n "$_f" || _f=-
	
	#-- sanity checks
	test -n "$_type" || pp_die "_type empty"
	test -n "$_path" || pp_die "_path empty"
	test -n "$_m" || pp_die "_m empty"
	test -n "$_o" || pp_die "_o empty"
	test -n "$_g" || pp_die "_g empty"

	pp_debug "$_type $_m $_o $_g $_f $_path" $_tgt
	$_ignore || echo "$_type $_m $_o $_g $_f $_path" $_tgt
        pp_note_file_used "$_path"
        case "$_f" in *i*) echo "$_path" >> $pp_wrkdir/ign.files;; esac
    done < $pp_wrkdir/tmp.files.exp
}

#@ pp_files_check_duplicates(): raise an error on duplicate files
pp_files_check_duplicates () {
    typeset _path
    if test -s $pp_wrkdir/all.files; then
        sort < $pp_wrkdir/all.files | uniq -d > $pp_wrkdir/duplicate.files
        while read _path; do
            pp_warn "$_path: file declared more than once"
        done <$pp_wrkdir/duplicate.files
    fi
}

#@ pp_files_check_coverage(): raise an error if files aren't listed
#  compares the list of files under pp_destdir with the list of
#  all files inside %files sections. Only generates warnings (for now.)
pp_files_check_coverage () {
    pp_find_recurse "$pp_destdir" | sort > $pp_wrkdir/coverage.avail
    if test -s $pp_wrkdir/all.files; then
        sort -u < $pp_wrkdir/all.files
    else
        :
    fi > $pp_wrkdir/coverage.used
    join -v1 $pp_wrkdir/coverage.avail $pp_wrkdir/coverage.used \
        > $pp_wrkdir/coverage.not-packaged
    if test -s $pp_wrkdir/coverage.not-packaged; then
        pp_warn "The following files/directories were found but not packaged:"
        sed -e 's,^,    ,' <  $pp_wrkdir/coverage.not-packaged >&2
    fi
    join -v2 $pp_wrkdir/coverage.avail $pp_wrkdir/coverage.used \
        > $pp_wrkdir/coverage.not-avail
    if test -s $pp_wrkdir/coverage.not-avail; then
        pp_warn "The following files/directories were named but not found:"
        sed -e 's,^,    ,' <  $pp_wrkdir/coverage.not-avail >&2
    fi
}

#@ pp_files_ignore_others(): remove ignored files
pp_files_ignore_others () {
    typeset p f

    test -s $pp_wrkdir/ign.files || return

    #-- for each file in ign.files, we remove it from all the
    #   other %files.* lists, except where it has an i flag.
    #   rather than scan each list multiple times, we build
    #   an awk script

    pp_debug "stripping ignore files"

    while read p; do
        echo '$6 == "'"$p"'" { skip unless $5 ~ /i/; }'
    done < $pp_wrkdir/ign.files > $pp_wrkdir/ign.awk

    $pp_opt_debug && cat $pp_wrkdir/ign.awk

    for f in $pp_wrkdir/%files.*; do
        awk -f $pp_wrkdir/ign.awk < $f > $f.i || pp_error "awk"
        mv $f.i $f
    done
}
