#
# misc utilities
#

#@ $pp_errors: true if pp_error() has been called
pp_errors=false

#@ $pp_components: whitespace-delimited list of components seen in %files
pp_components=
#@ $pp_services: whitespace-delimited list of %service seen
pp_services=

#-- define some colour strings
#@   $pp_col_redfg: terminal string to change foreground colour to red
#@   $pp_col_bluefg: terminal string to change foreground colour to blue
#@   $pp_col_reset: terminal string to reset colours to default
if test -t; then
   pp_col_redfg=`tput setf 4` 2>/dev/null
   pp_col_bluefg=`tput setf 1` 2>/dev/null
   pp_col_reset=`tput op` 2>/dev/null
else
   pp_col_redfg=
   pp_col_bluefg=
   pp_col_reset=
fi

#@ pp__warn(type,msg): prints a warning message including $pp_lineno if nonnull
pp__warn () {
	if test x"" = x"$pp_lineno"; then
	    echo "$1 $2" >&2
	else
	    echo "$1 line $pp_lineno: $2" >&2
	fi
}

#@ pp_warn(msg): prints a warning message
pp_warn () {
	pp__warn "${pp_col_redfg}[warning]${pp_col_reset}" "$*"
}

# pp_error(msg): prints an error message and sets $pp_errors to 'true'
pp_error () {
	pp__warn "${pp_col_redfg}[error]${pp_col_reset}" "$*"
	pp_errors=true
}

#@ pp_die(msg): prints an error message and dies with exit code 1
pp_die () {
	pp_error "$@"
	exit 1
}

#@ pp_die_if_errors(msg): dies with an error if previous errors had occurred
pp_die_if_errors () {
	$pp_errors && pp_die ${1+"$@"}
}

#@ pp_debug(msg): writes a message only if the --debug option was given
pp_debug () { 
	$pp_opt_debug && echo "${pp_col_bluefg}[debug]${pp_col_reset} $*" >&2
}

#@ pp_verbose(msg): writes a message only if the --verbose option was given
pp_verbose () {
	$pp_opt_verbose && echo "${pp_col_bluefg}$*${pp_col_reset}" >&2
	"$@";
}

#@ pp_substitute(): expands %{} and %() in standard input stream
#     - substitutes each %{var} with shell variable $var
#     - substitutes each %(cmd) with the output of `cmd`
#     - otherwise passes characters unchanged.
#     - assumes input does not contain ^U ^V ow ^W characters
pp_substitute () { 
  sed -e 's,%(\([^)]*\)),\n`\1`\n,g' \
      -e 's,%{\([^}]*\)},\n${\1}\n,g' \
      -e 's,$,,' |
  sed -e '/^[^]/s/["$`\\]/\\&/g' \
      -e 's/^//' \
      -e '1s/^/echo "/' \
      -e '$s,$,",' \
      -e 's,,"echo ",g' |
  tr -d '\012' |
  tr '' '\012'
  echo
}

#@ pp_incr(var): increements variable $var by one
pp_incr () {
    eval "$1=\`expr \$$1 + 1\`"
}

#@ pp_decr(var): decrements variable $var by one
pp_decr () {
    eval "$1=\`expr \$$1 - 1\`"
}

#@ pp_check_var_is_defined(): check the variable is set and/or non-empty
#   Otherwise, generates an error, and sets the variable to "undefined"
pp_check_var_is_defined () {
    if eval test -z "\"\$$1\""; then 
	pp_error "\$$1: not set"
	eval "$1=undefined"
    fi
}

#@ pp_contains(list word): true if list contains word. list is space-delimited
pp_contains () {
    case " $1 " in
       *" $2 "*) return 0;;
       *) return 1;;
    esac
}

#@ pp_contains_all(list word...): true if all words are found in the list
pp_contains_all () {
    typeset _s _c
    _l="$1"; shift
    for _w
    do
	pp_contains "$_l" "$_w" || return 1
    done
    return 0
}

#@ pp_contains_any(list word...): true if any word is found in the list
pp_contains_any () {
    typeset _s _c
    _l="$1"; shift
    for _w
    do
	pp_contains "$_l" "$_w" && return 0
    done
    return 1
}

#@ pp_add_to_list(list word): adds word into $list, if not there already
pp_add_to_list () {
    if eval test -z \"\$$1\"; then
	eval $1='"$2"'
    elif ! eval pp_contains '"$'$1'"' '"$2"'; then
	eval $1='"$'$1' $2"'
    fi
}
	

#@ pp_mode_from_ls(str): converts an ls mode pattern into an octal mode number
#   e.g. "-rw-rw-r--" becomes "664"
pp_mode_from_ls () {
   typeset umode gmode omode smode

   case "$1" in
	?--[-X]??????) umode=0;;
	?--[xs]??????) umode=1;;
	?-w[-X]??????) umode=2;;
	?-w[xs]??????) umode=3;;
	?r-[-X]??????) umode=4;;
	?r-[xs]??????) umode=5;;
	?rw[-X]??????) umode=6;;
	?rw[xs]??????) umode=7;;
	*) error "bad user mode $1";;
   esac

   case "$1" in
	????--[-S]???) gmode=0;;
	????--[xs]???) gmode=1;;
	????-w[-S]???) gmode=2;;
	????-w[xs]???) gmode=3;;
	????r-[-X]???) gmode=4;;
	????r-[xs]???) gmode=5;;
	????rw[-X]???) gmode=6;;
	????rw[xs]???) gmode=7;;
	*) error "bad group mode $1";;
   esac

   case "$1" in
	???????--[-T]) omode=0;;
	???????--[xt]) omode=1;;
	???????-w[-T]) omode=2;;
	???????-w[xt]) omode=3;;
	???????r-[-T]) omode=4;;
	???????r-[xt]) omode=5;;
	???????rw[-T]) omode=6;;
	???????rw[xt]) omode=7;;
	*) error "bad other mode $1";;
   esac

   case "$1" in
	???[-x]??[-x]??[-x]) smode=;;
	???[-x]??[-x]??[tT]) smode=1;;
	???[-x]??[Ss]??[-x]) smode=2;;
	???[-x]??[Ss]??[tT]) smode=3;;
	???[Ss]??[-x]??[-x]) smode=4;;
	???[Ss]??[-x]??[tT]) smode=5;;
	???[Ss]??[Ss]??[-x]) smode=6;;
	???[Ss]??[Ss]??[tT]) smode=7;;
	*) error "bad set-id mode $1";;
   esac

   echo "$smode$umode$gmode$omode"
}

#@ pp_find_recurse($pp_destdir/dir): recursive find (don't follow symlinks)
pp_find_recurse () {
  pp_debug "find: ${1#$pp_destdir}/"
  for f in "$1"/.* "$1"/*; do
    case "$f" in */.|*/..) continue;; esac  # should never happen!
    if test -d "$f" -o -f "$f" -o -h "$f"; then
        if test -d "$f" -a ! -h "$f"; then
            echo "${f#$pp_destdir}/"
            pp_find_recurse "$f"
        else
            echo "${f#$pp_destdir}"
        fi
    fi
  done
}

#@ pp_prepend(file) <text: prepend text to the beginning of the file
#   if file does not exist, it is created
pp_prepend () {
    #test -t && pp_warn "pp_prepend: stdin is a tty?"
    if test -f $1; then
        pp_debug "prepending to $1"
        mv $1 $1._prepend
        cat - $1._prepend >$1
        rm -f $1._prepend
    else
        pp_debug "prepend: creating $1"
        cat >$1
    fi
}

#@ pp_create_dir_if_missing(path,mode): add directory if missing
#   - cleans up afterwards
pp_create_dir_if_missing () {
    case "$1" in
        */) pp_error "pp_create_dir_if_missing: trailing / forbidden";;
	"") return 0;;
	*)  if test ! -d "$pp_destdir$1"; then
                pp_debug "fabricating directory $1/"
		pp_create_dir_if_missing "${1%/*}"
		mkdir "$pp_destdir$1" && 
                echo "$1/" >> $pp_wrkdir/all.files
		pp_remove_later "$1" &&
		chmod ${2-755} "$pp_destdir$1" 
	    fi;;
    esac
}

#@ pp_add_file_if_missing(path,cpt,mode): add file to component only if missing
#   returns false if the file already exists; otherwise adds
#   adds an entry to the %files.$cpt list. If the path is in a missing
#   directory, that directory is also created under $pp_destdir.
#   This is usually used for system scripts. The mode defaults to 755
#   and the component defaults to run. The file is scheduled for removal
#   after packaing is complete.
pp_add_file_if_missing () {
    typeset dir
    #-- check that the file isn't already declared in the component
    if test -s $pp_wrkdir/%files.${2:-run}; then
      awk "\$6 == \"$1\" {exit 1}" < $pp_wrkdir/%files.${2:-run} || return 1  
    fi
                
    pp_create_dir_if_missing "${1%/*}"
    pp_debug "fabricating file $1"
    echo "f ${3:-755} - - - $1" >> $pp_wrkdir/%files.${2:-run}
    echo "$1" >> $pp_wrkdir/all.files
    pp_remove_later "$1"
    return 0
}

#@ pp_remove_later(path): adds file for deletion during cleanup
#  the file is prepended to $pp_wrkdir/pp_cleanup
pp_remove_later () {
   {
	echo "$1"
	test -s $pp_wrkdir/pp_cleanup && cat $pp_wrkdir/pp_cleanup
   } > $pp_wrkdir/pp_cleanup.new
   mv $pp_wrkdir/pp_cleanup.new $pp_wrkdir/pp_cleanup
}

#@ pp_remove_later_now(): removes all files registered with pp_remove_later
pp_remove_later_now () {
    typeset f
    if test -s $pp_wrkdir/pp_cleanup; then
        pp_debug "pp_remove_later_now"
        while read f; do
            pp_debug "removing $pp_destdir$f"
	    if test -d $pp_destdir$f; then 
		rmdir $pp_destdir$f
	    else
		rm $pp_destdir$f
	    fi
        done < $pp_wrkdir/pp_cleanup
        rm $pp_wrkdir/pp_cleanup
    fi
}
